<haxe>
	<class path="Enum" params="T" file="/opt/haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="EReg" params="" file="/opt/haxe/std/EReg.hx">
		<r><d/></r>
		<last><c path="String"/></last>
		<global><e path="Bool"/></global>
		<pattern><c path="String"/></pattern>
		<options><c path="String"/></options>
		<re><c path="String"/></re>
		<matches><c path="ArrayAccess"><d/></c></matches>
		<match public="1" set="method" line="85">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the regular expression matches the String.
		Updates the internal state accordingly.
	</haxe_doc>
		</match>
		<matched public="1" set="method" line="125">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.
	</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="152">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was as the left of
		of the matched substring.
	</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="178">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was at the right of
		of the matched substring.
	</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="210">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>
		Returns the position of the matched substring within the
		original matched string.
	</haxe_doc>
		</matchedPos>
		<split public="1" set="method" line="230">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split a string by using the regular expression to match
		the separators.
	</haxe_doc>
		</split>
		<replace public="1" set="method" line="273">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.
	</haxe_doc>
		</replace>
		<customReplace public="1" set="method" line="339">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>
		For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.
	</haxe_doc>
		</customReplace>
		<new public="1" set="method" line="52">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new regular expression with pattern [r] and
		options [opt].
	</haxe_doc>
		</new>
		<haxe_doc>
	Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.
</haxe_doc>
	</class>
	<class path="php.PhpXml__" params="" file="/opt/haxe/std/php/PhpXml__.hx">
		<Element public="1" set="null" static="1"><e path="XmlType"/></Element>
		<PCData public="1" set="null" static="1"><e path="XmlType"/></PCData>
		<CData public="1" set="null" static="1"><e path="XmlType"/></CData>
		<Comment public="1" set="null" static="1"><e path="XmlType"/></Comment>
		<DocType public="1" set="null" static="1"><e path="XmlType"/></DocType>
		<Prolog public="1" set="null" static="1"><e path="XmlType"/></Prolog>
		<Document public="1" set="null" static="1"><e path="XmlType"/></Document>
		<build static="1"><c path="php.PhpXml__"/></build>
		<__start_element_handler set="method" line="50" static="1"><f a="parser:name:attribs">
	<d/>
	<c path="String"/>
	<c path="ArrayAccess"><c path="String"/></c>
	<e path="Void"/>
</f></__start_element_handler>
		<__end_element_handler set="method" line="57" static="1"><f a="parser:name">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></__end_element_handler>
		<__character_data_handler set="method" line="61" static="1"><f a="parser:data">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></__character_data_handler>
		<__default_handler set="method" line="73" static="1"><f a="parser:data">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></__default_handler>
		<xmlChecker line="77" static="1"><c path="EReg"/></xmlChecker>
		<parse public="1" set="method" line="79" static="1"><f a="str">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></parse>
		<createElement public="1" set="method" line="112" static="1"><f a="name">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createElement>
		<createPCData public="1" set="method" line="121" static="1"><f a="data">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createPCData>
		<createCData public="1" set="method" line="128" static="1"><f a="data">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createCData>
		<createComment public="1" set="method" line="135" static="1"><f a="data">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createComment>
		<createDocType public="1" set="method" line="142" static="1"><f a="data">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createDocType>
		<createProlog public="1" set="method" line="149" static="1"><f a="data">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createProlog>
		<createDocument public="1" set="method" line="156" static="1"><f a=""><c path="php.PhpXml__"/></f></createDocument>
		<nodeType public="1" set="null"><e path="XmlType"/></nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName"><c path="String"/></nodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue"><c path="String"/></nodeValue>
		<parent public="1" get="getParent" set="null"><c path="php.PhpXml__"/></parent>
		<_nodeName public="1"><c path="String"/></_nodeName>
		<_nodeValue public="1"><c path="String"/></_nodeValue>
		<_attributes public="1"><c path="Hash"><c path="String"/></c></_attributes>
		<_children public="1"><c path="Array"><c path="php.PhpXml__"/></c></_children>
		<_parent public="1"><c path="php.PhpXml__"/></_parent>
		<getNodeName set="method" line="163"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName set="method" line="169"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeValue set="method" line="175"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue set="method" line="181"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getParent set="method" line="187"><f a=""><c path="php.PhpXml__"/></f></getParent>
		<get public="1" set="method" line="191"><f a="att">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<set public="1" set="method" line="197"><f a="att:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></set>
		<remove public="1" set="method" line="203"><f a="att">
	<c path="String"/>
	<e path="Void"/>
</f></remove>
		<exists public="1" set="method" line="209"><f a="att">
	<c path="String"/>
	<e path="Bool"/>
</f></exists>
		<attributes public="1" set="method" line="215"><f a=""><t path="Iterator"><c path="String"/></t></f></attributes>
		<iterator public="1" set="method" line="221"><f a=""><t path="Iterator"><c path="php.PhpXml__"/></t></f></iterator>
		<elements public="1" set="method" line="238"><f a=""><t path="Iterator"><c path="php.PhpXml__"/></t></f></elements>
		<elementsNamed public="1" set="method" line="274"><f a="name">
	<c path="String"/>
	<t path="Iterator"><c path="php.PhpXml__"/></t>
</f></elementsNamed>
		<firstChild public="1" set="method" line="311"><f a=""><c path="php.PhpXml__"/></f></firstChild>
		<firstElement public="1" set="method" line="317"><f a=""><c path="php.PhpXml__"/></f></firstElement>
		<addChild public="1" set="method" line="330"><f a="x">
	<c path="php.PhpXml__"/>
	<e path="Void"/>
</f></addChild>
		<removeChild public="1" set="method" line="337"><f a="x">
	<c path="php.PhpXml__"/>
	<e path="Bool"/>
</f></removeChild>
		<insertChild public="1" set="method" line="345"><f a="x:pos">
	<c path="php.PhpXml__"/>
	<c path="Int"/>
	<e path="Void"/>
</f></insertChild>
		<toString public="1" set="method" line="352"><f a=""><c path="String"/></f></toString>
		<new set="method" line="110"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="php.db.Connection" params="" file="/opt/haxe/std/php/db/Connection.hx" interface="1">
		<request public="1" set="method"><f a="s">
	<c path="String"/>
	<c path="php.db.ResultSet"/>
</f></request>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<escape public="1" set="method"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></escape>
		<quote public="1" set="method"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></quote>
		<addValue public="1" set="method"><f a="s:v">
	<c path="StringBuf"/>
	<d/>
	<e path="Void"/>
</f></addValue>
		<lastInsertId public="1" set="method"><f a=""><c path="Int"/></f></lastInsertId>
		<dbName public="1" set="method"><f a=""><c path="String"/></f></dbName>
		<startTransaction public="1" set="method"><f a=""><e path="Void"/></f></startTransaction>
		<commit public="1" set="method"><f a=""><e path="Void"/></f></commit>
		<rollback public="1" set="method"><f a=""><e path="Void"/></f></rollback>
	</class>
	<class path="php.Sys" params="" file="/opt/haxe/std/php/Sys.hx">
		<args public="1" set="method" line="5" static="1"><f a=""><c path="Array"><c path="String"/></c></f></args>
		<getEnv public="1" set="method" line="9" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></getEnv>
		<putEnv public="1" set="method" line="13" static="1"><f a="s:v">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></putEnv>
		<sleep public="1" set="method" line="17" static="1"><f a="seconds">
	<c path="Float"/>
	<unknown/>
</f></sleep>
		<setTimeLocale public="1" set="method" line="21" static="1"><f a="loc">
	<c path="String"/>
	<e path="Bool"/>
</f></setTimeLocale>
		<getCwd public="1" set="method" line="25" static="1"><f a=""><c path="String"/></f></getCwd>
		<setCwd public="1" set="method" line="31" static="1"><f a="s">
	<c path="String"/>
	<unknown/>
</f></setCwd>
		<systemName public="1" set="method" line="35" static="1"><f a=""><c path="String"/></f></systemName>
		<escapeArgument public="1" set="method" line="44" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" set="method" line="58" static="1"><f a="cmd:?args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="Int"/>
</f></command>
		<exit public="1" set="method" line="71" static="1"><f a="code">
	<c path="Int"/>
	<unknown/>
</f></exit>
		<time public="1" set="method" line="75" static="1"><f a=""><c path="Float"/></f></time>
		<cpuTime public="1" set="method" line="79" static="1"><f a=""><c path="Float"/></f></cpuTime>
		<executablePath public="1" set="method" line="83" static="1"><f a=""><c path="String"/></f></executablePath>
		<environment public="1" set="method" line="87" static="1"><f a=""><c path="Hash"><c path="String"/></c></f></environment>
	</class>
	<class path="MainApp" params="" file="src/MainApp.hx">
		<startTime public="1" line="10" static="1"><c path="Float"/></startTime>
		<main public="1" set="method" line="12" static="1"><f a=""><e path="Void"/></f></main>
		<testing public="1" set="method" line="28" static="1"><f a=""><e path="Void"/></f></testing>
		<printStats public="1" set="method" line="77" static="1"><f a=""><e path="Void"/></f></printStats>
	</class>
	<class path="AppConfig" params="" file="src/AppConfig.hx">
		<defaultController public="1" line="11" static="1">
			<c path="Class"><d/></c>
			<haxe_doc> Default Controller </haxe_doc>
		</defaultController>
		<baseUrl public="1" line="25" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[ Set this to the base URL of your site, not including a trailing slash.
	
	Examples:
	<ul>
		<li>http://www.mysite.com</li>
		<li>http://www.mysite.com/myapp</li>
	</ul>
	]]></haxe_doc>
		</baseUrl>
		<subDir public="1" line="28" static="1">
			<c path="String"/>
			<haxe_doc> The subdirectory on the server we are in.  No trailing slash </haxe_doc>
		</subDir>
		<baseFilePath public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[ Set this to the base filepath of this app on your server,
	(do not include a trailing slash).
	
	Examples:
	<ul>
		<li>/var/www/html</li>
		<li>/home/website</li>
		<li>/home/website/myapp</li>
	</ul>
	
	<b>This property might not be needed... not sure yet.  
	Remember Haxe's import mechanism is alot nicer than PHPs</b>
	]]></haxe_doc>
		</baseFilePath>
		<dbServer public="1" line="52" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[ The address of the database server.  Usually <i>localhost</i>]]></haxe_doc>
		</dbServer>
		<dbPort public="1" line="55" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[ The port of the database server.  Usually <i>3306</i>]]></haxe_doc>
		</dbPort>
		<dbDatabase public="1" line="58" static="1">
			<c path="String"/>
			<haxe_doc> The name of the database to use </haxe_doc>
		</dbDatabase>
		<dbUsername public="1" line="61" static="1">
			<c path="String"/>
			<haxe_doc> The username to use when logging in to the database server </haxe_doc>
		</dbUsername>
		<dbPassword public="1" line="64" static="1">
			<c path="String"/>
			<haxe_doc> The password to use when logging in to the database server </haxe_doc>
		</dbPassword>
		<tablePrefix public="1" static="1">
			<c path="String"/>
			<haxe_doc> If you have multiple apps (or versions of apps) on this database,
	you can specify a table prefix to keep table names from overlapping
	each other.  For example, "myapp1.0_" </haxe_doc>
		</tablePrefix>
		<haxe_doc>
This class contains all the config for your app.
I'm not sure which package this should belong in really...
</haxe_doc>
	</class>
	<class path="php.NativeArray" params="" file="/opt/haxe/std/php/NativeArray.hx" extern="1"/>
	<class path="php.db._Mysql.MysqlConnection" params="" file="/opt/haxe/std/php/db/Mysql.hx" private="1" module="php.db.Mysql">
		<implements path="php.db.Connection"/>
		<c><e path="Void"/></c>
		<close public="1" set="method" line="37"><f a=""><e path="Void"/></f></close>
		<request public="1" set="method" line="42"><f a="s">
	<c path="String"/>
	<c path="php.db.ResultSet"/>
</f></request>
		<escape public="1" set="method" line="49"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></escape>
		<quote public="1" set="method" line="53"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></quote>
		<addValue public="1" set="method" line="57"><f a="s:v">
	<c path="StringBuf"/>
	<d/>
	<e path="Void"/>
</f></addValue>
		<lastInsertId public="1" set="method" line="66"><f a=""><c path="Int"/></f></lastInsertId>
		<dbName public="1" set="method" line="70"><f a=""><c path="String"/></f></dbName>
		<startTransaction public="1" set="method" line="74"><f a=""><e path="Void"/></f></startTransaction>
		<commit public="1" set="method" line="78"><f a=""><e path="Void"/></f></commit>
		<rollback public="1" set="method" line="82"><f a=""><e path="Void"/></f></rollback>
		<new public="1" set="method" line="33"><f a="c">
	<e path="Void"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="php.db.ResultSet" params="" file="/opt/haxe/std/php/db/ResultSet.hx" interface="1">
		<length public="1" get="getLength" set="null"><c path="Int"/></length>
		<nfields public="1" get="getNFields" set="null"><c path="Int"/></nfields>
		<hasNext public="1" set="method"><f a=""><e path="Bool"/></f></hasNext>
		<next public="1" set="method"><f a=""><d/></f></next>
		<results public="1" set="method"><f a=""><c path="List"><d/></c></f></results>
		<getResult public="1" set="method"><f a="n">
	<c path="Int"/>
	<c path="String"/>
</f></getResult>
		<getIntResult public="1" set="method"><f a="n">
	<c path="Int"/>
	<c path="Int"/>
</f></getIntResult>
		<getFloatResult public="1" set="method"><f a="n">
	<c path="Int"/>
	<c path="Float"/>
</f></getFloatResult>
	</class>
	<class path="php.db._Mysql.MysqlResultSet" params="" file="/opt/haxe/std/php/db/Mysql.hx" private="1" module="php.db.Mysql">
		<implements path="php.db.ResultSet"/>
		<length public="1" get="getLength" set="null"><c path="Int"/></length>
		<nfields public="1" get="getNFields" set="null"><c path="Int"/></nfields>
		<__r><e path="Void"/></__r>
		<cache><d/></cache>
		<getLength set="method" line="98"><f a=""><c path="Int"/></f></getLength>
		<_nfields><c path="Int"/></_nfields>
		<getNFields set="method" line="107"><f a=""><c path="Int"/></f></getNFields>
		<_fieldsDesc><c path="Array"><d/></c></_fieldsDesc>
		<getFieldsDescription set="method" line="114"><f a=""><c path="Array"><d/></c></f></getFieldsDescription>
		<convert set="method" line="128"><f a="v:type">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></convert>
		<hasNext public="1" set="method" line="142"><f a=""><e path="Bool"/></f></hasNext>
		<cRow><c path="ArrayAccess"><c path="String"/></c></cRow>
		<fetchRow set="method" line="149"><f a=""><e path="Bool"/></f></fetchRow>
		<next public="1" set="method" line="154"><f a=""><d/></f></next>
		<results public="1" set="method" line="169"><f a=""><c path="List"><d/></c></f></results>
		<getResult public="1" set="method" line="176"><f a="n">
	<c path="Int"/>
	<c path="String"/>
</f></getResult>
		<getIntResult public="1" set="method" line="183"><f a="n">
	<c path="Int"/>
	<c path="Int"/>
</f></getIntResult>
		<getFloatResult public="1" set="method" line="187"><f a="n">
	<c path="Int"/>
	<c path="Float"/>
</f></getFloatResult>
		<new public="1" set="method" line="94"><f a="r">
	<e path="Void"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="php.db.Mysql" params="" file="/opt/haxe/std/php/db/Mysql.hx"><connect public="1" set="method" line="194" static="1"><f a="params">
	<a>
		<user><c path="String"/></user>
		<socket><c path="String"/></socket>
		<port><c path="Int"/></port>
		<pass><c path="String"/></pass>
		<host><c path="String"/></host>
		<database><c path="String"/></database>
	</a>
	<c path="php.db.Connection"/>
</f></connect></class>
	<enum path="XmlType" params="" file="/opt/haxe/std/Xml.hx" module="Xml"><haxe_doc>
	An abstract type representing the type of the Xml
	Node. You can compare it to [Xml] statics and can
	use [Std.string(t)] to get a string reprensation
	of the type.
</haxe_doc></enum>
	<class path="Xml" params="" file="/opt/haxe/std/Xml.hx" extern="1">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Document>
		<parse public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Parse a String into an Xml object.
	</haxe_doc>
		</parse>
		<createElement public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createCData>
		<createComment public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocType>
		<createProlog public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createProlog>
		<createDocument public="1" set="method" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>
		Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.
	</haxe_doc>
		</nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>
		Returns the node name of an Element.
	</haxe_doc>
		</nodeName>
		<getNodeName set="method"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>
		Returns the node value. Only works if the Xml node is not an Element or a Document.
	</haxe_doc>
		</nodeValue>
		<getNodeValue set="method"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<get public="1" set="method">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.
	</haxe_doc>
		</get>
		<set public="1" set="method">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the given attribute value for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</set>
		<remove public="1" set="method">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Removes an attribute for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</remove>
		<exists public="1" set="method">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the Element node has a given attribute.
		Attributes are case-sensitive.
	</haxe_doc>
		</exists>
		<attributes public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an [Iterator] on all the attributes values.
	</haxe_doc>
		</attributes>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>
		Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.
	</haxe_doc>
		</parent>
		<getParent set="method"><f a=""><c path="Xml"/></f></getParent>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</iterator>
		<elements public="1" set="method">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node.
	</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node which is an Element.
	</haxe_doc>
		</firstElement>
		<addChild public="1" set="method">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.
	</haxe_doc>
		</addChild>
		<removeChild public="1" set="method">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.
	</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts a child at the given position among the other childs.
	</haxe_doc>
		</insertChild>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a String representation of the Xml node.
	</haxe_doc>
		</toString>
		<haxe_doc>
	The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.
</haxe_doc>
	</class>
	<class path="Reflect" params="" file="/opt/haxe/std/Reflect.hx">
		<hasField public="1" get="inline" set="null" line="35" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" set="method" line="61" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="87" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" set="method" line="106" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="135" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="210" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="231" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="243" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
		Does not work on Neko platform.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="275" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="319" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="349" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="372" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="/opt/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="43" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<class path="php.db.Object" params="" file="/opt/haxe/std/php/db/Object.hx">
		<__cache__><c path="php.db.Object"/></__cache__>
		<__noupdate__><e path="Bool"/></__noupdate__>
		<__manager__><a>
	<objectToString set="method"><f a="o">
	<c path="php.db.Object"/>
	<c path="String"/>
</f></objectToString>
	<doUpdate set="method"><f a="o">
	<c path="php.db.Object"/>
	<e path="Void"/>
</f></doUpdate>
	<doSync set="method"><f a="o">
	<c path="php.db.Object"/>
	<e path="Void"/>
</f></doSync>
	<doInsert set="method"><f a="o">
	<c path="php.db.Object"/>
	<e path="Void"/>
</f></doInsert>
	<doDelete set="method"><f a="o">
	<c path="php.db.Object"/>
	<e path="Void"/>
</f></doDelete>
</a></__manager__>
		<__init_object set="method" line="59"><f a=""><e path="Void"/></f></__init_object>
		<insert public="1" set="method" line="71"><f a=""><e path="Void"/></f></insert>
		<update public="1" set="method" line="75"><f a=""><e path="Void"/></f></update>
		<sync public="1" set="method" line="80"><f a=""><e path="Void"/></f></sync>
		<delete public="1" set="method" line="84"><f a=""><e path="Void"/></f></delete>
		<toString public="1" set="method" line="88"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="55"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	SPOD Object : the persistent object base type. See the tutorial on haXe
	website to learn how to use SPOD.
</haxe_doc>
	</class>
	<class path="hxbase.BaseDbModel" params="" file="src/hxbase/BaseDbModel.hx">
		<extends path="php.db.Object"/>
		<new public="1" set="method" line="107"><f a=""><e path="Void"/></f></new>
		<haxe_doc><![CDATA[ 
<b>Conventions</b>
<br />This model follows a few simple conventions
<ul>
	<li>The database details will already be defined in AppConfig.</li>
	<li>The database table will have the same name as this class.</li>
	<li>The primary id will be a column called 'id'.</li>
</ul>
Follow these and you'll be off to a good start.

<b>Various Variable Names</b>
<ul>
	<li>When you extend this class, you'll need to define a public 
	variable for each column in your table.</li>
	<li>Basic definitions are public and non-static, like:
	<br />public var name : String;</li>
	<li>How you know which type to use:
		<ul>
			<li>Int: TINYINT SHORT LONG INT24</li>
			<li>Float: LONGLONG, DECIMAL, FLOAT, DOUBLE</li>
			<li>Bool: TINYINT(1)</li>
			<li>Date: DATE, DATETIME</li>
			<li>String: <All Others> (note - BLOB can contain \0)</li>
		</ul>
	</li>
</ul>

<b>The Manager</b>
<ul>
	<li>You use the manager to perform searches and SELECT statements, basically</li>
	<li>You'll have to add this line right before the end of your class definition:
	<br />public static var manager = new php.db.Manager< MyModelName >(MyModelName);</li>
</ul>

<b>Relationships</b>
<ul>
	<li><b>One to one</b> or <b>Belongs to</b>.
	<br />These relationships are built in by haxe.  You'll 
	need to include something like this:
	<pre>static function RELATIONS() 
{
	return &#91{ prop : "user", key : "userId", manager : User.manager }];
}</pre>

	Basically, you need a static function, which returns 
	an array with the details of each relationships.  The fields are:
	<ul>
		<li>prop: The name of the property in this object 
		that you want to store the related object in.</li>
		<li>key: The name of the property in this object
		that has the key for the related object.</li>
		<li>manager: The link to the manager for the Class 
		of the related object.</li>
	</ul>
	
	To insert multiple, do:
	<pre>static function RELATIONS() 
{
	return &#91{ prop : "profile", key : "profileId", manager : Profile.manager },
	{ prop : "mother", key : "motherId", manager : User.manager },
	{ prop : "father", key : "fatherId", manager : User.manager }];
}</pre>

... or something to that effect.</li>
	<li><b>Has Many</b>
	<br />This sort of relationship doesn't come built in in haxe,
	but wasn't very hard to get going.  I put in a bit of code like
	this:
	<pre>	public var todoList(getter_todoList,null):List<TodoItem>;
	private function getter_todoList():List<TodoItem> 
	{
		return (id == null) ? 
			new List<TodoItem>() : 
			TodoItem.manager.search({ userId : id }); 
	}</pre>
	Just replace "todoList" with whatever you want to call
	your list of child objects, and "TodoItem" with the 
	Class name for the model of your child objects.
	</li>
	<li><b>HABTM</b>
	<br />What?  Has And Belongs To Many, apparently.  This isn't as
	common, sometimes seen in tags.  It's a many-to-many, (a much better name)
	and usually needs a joining table.  I haven't gone and done these yet...
	<br />I imagine you could do it by having a model for the joining table
	and just doing a hasMany relationship from Model1 -> ModelJoin and from
	ModelJoin -> Model2.  There might be a more elegant way also...</li>
	
</ul>

<b>Automating this</b>

Boring!  Typing in all this stuff could probably be automated 
to be read directly from the database...

<b>Validation</b>

I'm still going to have to think about this

<b>General Usage</b>

Have a look at <a href="http://haxe.org/doc/neko/spod">the haxe SPOD tutorial</a>,
because that's what all this is based on.
]]></haxe_doc>
	</class>
	<class path="hxbase.Dispatcher" params="" file="src/hxbase/Dispatcher.hx">
		<dispatch public="1" set="method" line="15" static="1">
			<f a="request">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Takes a request query (usually from the URL) decides
	which controller class to use, passing any extra parameters
	to it as necessary. </haxe_doc>
		</dispatch>
		<getRequestParts set="method" line="44" static="1"><f a="request">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getRequestParts>
		<haxe_doc>
The Dispatcher class is responsible for deciding which
Controller class is being requested and which action 
should be executed.

This class is called on most page requests.  
</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/opt/haxe/std/StringBuf.hx">
		<add public="1" get="inline" set="null" line="48">
			<f a="?x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="61">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="79">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="95">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="String"/></b>
		<new public="1" set="method" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="php.Boot" params="" file="/opt/haxe/std/php/Boot.hx">
		<qtypes static="1"><c path="Array"><unknown/></c></qtypes>
		<ttypes static="1"><unknown/></ttypes>
		<tpaths static="1"><unknown/></tpaths>
		<skip_constructor line="7" static="1"><e path="Bool"/></skip_constructor>
	</class>
	<class path="php.IteratorAggregate" params="T" file="/opt/haxe/std/php/IteratorAggregate.hx" extern="1" interface="1"><getIterator set="method">
	<f a=""><t path="Iterator"><c path="php.IteratorAggregate.T"/></t></f>
	<haxe_doc> 
		This method is not public to not induce haXe users to use it ;) 
		Use iterator() instead.
		The return type would be Aggregator that is unusable in haXe 
	</haxe_doc>
</getIterator></class>
	<class path="Hash" params="T" file="/opt/haxe/std/Hash.hx">
		<implements path="php.IteratorAggregate"><c path="Hash.T"/></implements>
		<h><c path="ArrayAccess"><c path="Hash.T"/></c></h>
		<set public="1" set="method" line="63">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="80">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="102">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="133">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="165">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="195">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="240">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<getIterator set="method" line="259">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Implement IteratorAggregate for native php iteration
	</haxe_doc>
		</getIterator>
		<new public="1" set="method" line="38">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="php.db.Manager" params="T" file="/opt/haxe/std/php/db/Manager.hx">
		<cnx public="1" set="setConnection" static="1"><c path="php.db.Connection"/></cnx>
		<object_cache line="38" static="1"><c path="Hash"><c path="php.db.Object"/></c></object_cache>
		<cache_field line="39" static="1"><c path="String"/></cache_field>
		<FOR_UPDATE line="40" static="1"><c path="String"/></FOR_UPDATE>
		<managers public="1" line="42" static="1"><c path="Hash"><c path="php.db.Manager"><d/></c></c></managers>
		<setConnection set="dynamic" line="44" static="1"><f a="c">
	<c path="php.db.Connection"/>
	<c path="php.db.Connection"/>
</f></setConnection>
		<initialize public="1" set="method" line="440" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	* Left for compability with neko SPOD
	</haxe_doc>
		</initialize>
		<cleanup public="1" set="method" line="444" static="1"><f a=""><e path="Void"/></f></cleanup>
		<table_name><c path="String"/></table_name>
		<table_fields><c path="List"><c path="String"/></c></table_fields>
		<table_keys><c path="Array"><c path="String"/></c></table_keys>
		<cls><d/></cls>
		<get public="1" set="method" line="116"><f a="id:?lock">
	<c path="Int"/>
	<e path="Bool"/>
	<c path="php.db.Manager.T"/>
</f></get>
		<getWithKeys public="1" set="method" line="138"><f a="keys:?lock">
	<a/>
	<e path="Bool"/>
	<c path="php.db.Manager.T"/>
</f></getWithKeys>
		<delete public="1" set="method" line="154"><f a="x">
	<a/>
	<e path="Void"/>
</f></delete>
		<search public="1" set="method" line="163"><f a="x:?lock">
	<a/>
	<e path="Bool"/>
	<c path="List"><c path="php.db.Manager.T"/></c>
</f></search>
		<addCondition set="method" line="176"><f a="s:x">
	<c path="StringBuf"/>
	<a/>
	<e path="Void"/>
</f></addCondition>
		<all public="1" set="method" line="197"><f a="?lock">
	<e path="Bool"/>
	<c path="List"><c path="php.db.Manager.T"/></c>
</f></all>
		<count public="1" set="method" line="203"><f a="?x">
	<a/>
	<c path="Int"/>
</f></count>
		<quote public="1" set="method" line="212"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></quote>
		<result public="1" set="method" line="216"><f a="sql">
	<c path="String"/>
	<d/>
</f></result>
		<results public="1" params="T" set="method" line="220"><f a="sql">
	<c path="String"/>
	<c path="List"><c path="results.T"/></c>
</f></results>
		<doInsert set="method" line="226"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></doInsert>
		<doUpdate set="method" line="259"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></doUpdate>
		<doDelete set="method" line="288"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></doDelete>
		<doSync set="method" line="298"><f a="i">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></doSync>
		<objectToString set="method" line="312"><f a="it">
	<c path="php.db.Manager.T"/>
	<c path="String"/>
</f></objectToString>
		<cacheObject set="method" line="337"><f a="x:lock">
	<c path="php.db.Manager.T"/>
	<e path="Bool"/>
	<c path="php.db.Manager.T"/>
</f></cacheObject>
		<make set="method" line="350"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></make>
		<unmake set="method" line="353"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></unmake>
		<quoteField set="method" line="356"><f a="f">
	<c path="String"/>
	<c path="String"/>
</f></quoteField>
		<addKeys set="method" line="363"><f a="s:x">
	<c path="StringBuf"/>
	<a/>
	<e path="Void"/>
</f></addKeys>
		<execute set="method" line="379"><f a="sql">
	<c path="String"/>
	<c path="php.db.ResultSet"/>
</f></execute>
		<select set="method" line="383"><f a="cond">
	<c path="String"/>
	<c path="String"/>
</f></select>
		<selectReadOnly set="method" line="393"><f a="cond">
	<c path="String"/>
	<c path="String"/>
</f></selectReadOnly>
		<object public="1" set="method" line="402"><f a="sql:lock">
	<c path="String"/>
	<e path="Bool"/>
	<c path="php.db.Manager.T"/>
</f></object>
		<objects public="1" set="method" line="414"><f a="sql:lock">
	<c path="String"/>
	<e path="Bool"/>
	<c path="List"><c path="php.db.Manager.T"/></c>
</f></objects>
		<dbClass public="1" set="method" line="431"><f a=""><c path="Class"><d/></c></f></dbClass>
		<initRelation set="method" line="448"><f a="o:r">
	<d/>
	<a>
		<prop><c path="String"/></prop>
		<manager><c path="php.db.Manager"><c path="php.db.Object"/></c></manager>
		<lock><e path="Bool"/></lock>
		<key><c path="String"/></key>
	</a>
	<e path="Void"/>
</f></initRelation>
		<makeCacheKey set="method" line="467"><f a="x">
	<c path="php.db.Manager.T"/>
	<c path="String"/>
</f></makeCacheKey>
		<addToCache set="method" line="486"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></addToCache>
		<getFromCache set="method" line="490"><f a="x:lock">
	<c path="php.db.Manager.T"/>
	<e path="Bool"/>
	<c path="php.db.Manager.T"/>
</f></getFromCache>
		<new public="1" set="method" line="57"><f a="classval">
	<c path="Class"><c path="php.db.Object"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	SPOD Manager : the persistent object database manager. See the tutorial on
	haXe website to learn how to use SPOD.
</haxe_doc>
	</class>
	<class path="models.TodoItem" params="" file="src/models/TodoItem.hx">
		<extends path="hxbase.BaseDbModel"/>
		<RELATIONS set="method" line="14" static="1"><f a=""><c path="Array"><a>
	<prop><c path="String"/></prop>
	<manager><c path="php.db.Manager"><c path="models.User"/></c></manager>
	<key><c path="String"/></key>
</a></c></f></RELATIONS>
		<manager public="1" line="20" static="1"><c path="php.db.Manager"><c path="models.TodoItem"/></c></manager>
		<id public="1"><c path="Int"/></id>
		<userId public="1"><c path="Int"/></userId>
		<subject public="1"><c path="String"/></subject>
		<text public="1"><c path="String"/></text>
		<priority public="1"><c path="Int"/></priority>
		<completion public="1"><c path="Float"/></completion>
		<user public="1" get="get_user" set="set_user"><c path="models.User"/></user>
		<new public="1" set="method" line="3"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="models.User" params="" file="src/models/User.hx">
		<extends path="hxbase.BaseDbModel"/>
		<manager public="1" line="16" static="1"><c path="php.db.Manager"><c path="models.User"/></c></manager>
		<id public="1"><c path="Int"/></id>
		<username public="1"><c path="String"/></username>
		<password public="1"><c path="String"/></password>
		<todoList public="1" get="getter_todoList" set="null"><c path="List"><c path="models.TodoItem"/></c></todoList>
		<getter_todoList set="method" line="11"><f a=""><c path="List"><c path="models.TodoItem"/></c></f></getter_todoList>
		<new public="1" set="method" line="3"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Date" params="" file="/opt/haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new date object.
	</haxe_doc>
		</new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="IntIter" params="" file="/opt/haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="Std" params="" file="/opt/haxe/std/Std.hx">
		<is public="1" set="method" line="34" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="54" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="74" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="90" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="131" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="153" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<enum path="Void" params="" file="/opt/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="/opt/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="/opt/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="/opt/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/opt/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/opt/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/opt/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/opt/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/opt/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="hxbase.DbControl" params="" file="src/hxbase/DbControl.hx">
		<cnx public="1" line="5" static="1"><c path="php.db.Connection"/></cnx>
		<connect public="1" set="method" line="7" static="1"><f a=""><e path="Void"/></f></connect>
		<close public="1" set="method" line="37" static="1"><f a=""><e path="Void"/></f></close>
	</class>
	<class path="List" params="T" file="/opt/haxe/std/List.hx">
		<implements path="php.IteratorAggregate"><c path="List.T"/></implements>
		<h><c path="ArrayAccess"><d/></c></h>
		<q><c path="ArrayAccess"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="56">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="76">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="100">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="108">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="118">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="132">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="149">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="190">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="215">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="235">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="254">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="270">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<getIterator set="method" line="285">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Implement IteratorAggregate for native php iteration
	</haxe_doc>
		</getIterator>
		<new public="1" set="method" line="49">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<class path="php.Lib" params="" file="/opt/haxe/std/php/Lib.hx">
		<print public="1" set="method" line="7" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output.
	</haxe_doc>
		</print>
		<println public="1" set="method" line="14" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output followed by a newline character.
	</haxe_doc>
		</println>
		<dump public="1" set="method" line="19" static="1"><f a="v">
	<d/>
	<e path="Void"/>
</f></dump>
		<serialize public="1" set="method" line="27" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize using native PHP serialization. This will return a Binary string that can be
		stored for long term usage.
	</haxe_doc>
		</serialize>
		<unserialize public="1" set="method" line="34" static="1">
			<f a="s">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a string using native PHP serialization. See [serialize].
	</haxe_doc>
		</unserialize>
		<extensionLoaded public="1" set="method" line="38" static="1"><f a="name">
	<c path="String"/>
	<unknown/>
</f></extensionLoaded>
		<isCli public="1" set="method" line="42" static="1"><f a=""><e path="Bool"/></f></isCli>
		<printFile public="1" set="method" line="46" static="1"><f a="file">
	<c path="String"/>
	<unknown/>
</f></printFile>
		<toPhpArray public="1" get="inline" set="null" line="50" static="1"><f a="a">
	<c path="Array"><d/></c>
	<c path="php.NativeArray"/>
</f></toPhpArray>
		<toHaxeArray public="1" get="inline" set="null" line="54" static="1"><f a="a">
	<c path="php.NativeArray"/>
	<c path="Array"><d/></c>
</f></toHaxeArray>
		<hashOfAssociativeArray public="1" params="T" set="method" line="58" static="1"><f a="arr">
	<c path="php.NativeArray"/>
	<c path="Hash"><c path="hashOfAssociativeArray.T"/></c>
</f></hashOfAssociativeArray>
		<associativeArrayOfHash public="1" set="method" line="64" static="1"><f a="hash">
	<c path="Hash"><d/></c>
	<c path="php.NativeArray"/>
</f></associativeArrayOfHash>
		<rethrow public="1" get="inline" set="null" line="71" static="1">
			<f a="e">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		For neko compatibility only.
	</haxe_doc>
		</rethrow>
		<appendType set="method" line="80" static="1"><f a="o:path:t">
	<d/>
	<c path="Array"><c path="String"/></c>
	<d/>
	<e path="Void"/>
</f></appendType>
		<getClasses public="1" set="method" line="91" static="1"><f a=""><a/></f></getClasses>
	</class>
	<class path="php.PhpDate__" params="" file="/opt/haxe/std/php/PhpDate__.hx">
		<__name__ line="29" static="1"><c path="Array"><c path="String"/></c></__name__>
		<now public="1" set="method" line="77" static="1"><f a=""><c path="php.PhpDate__"/></f></now>
		<fromPhpTime public="1" set="method" line="81" static="1"><f a="t">
	<c path="Float"/>
	<c path="php.PhpDate__"/>
</f></fromPhpTime>
		<fromTime public="1" set="method" line="87" static="1"><f a="t">
	<c path="Float"/>
	<c path="php.PhpDate__"/>
</f></fromTime>
		<fromString public="1" set="method" line="93" static="1"><f a="s">
	<c path="String"/>
	<c path="php.PhpDate__"/>
</f></fromString>
		<__t><c path="Float"/></__t>
		<getTime public="1" set="method" line="36"><f a=""><c path="Float"/></f></getTime>
		<getPhpTime public="1" set="method" line="40"><f a=""><c path="Float"/></f></getPhpTime>
		<getFullYear public="1" set="method" line="44"><f a=""><c path="Int"/></f></getFullYear>
		<getMonth public="1" set="method" line="48"><f a=""><c path="Int"/></f></getMonth>
		<getDate public="1" set="method" line="53"><f a=""><c path="Int"/></f></getDate>
		<getHours public="1" set="method" line="57"><f a=""><c path="Int"/></f></getHours>
		<getMinutes public="1" set="method" line="61"><f a=""><c path="Int"/></f></getMinutes>
		<getSeconds public="1" set="method" line="65"><f a=""><c path="Int"/></f></getSeconds>
		<getDay public="1" set="method" line="69"><f a=""><c path="Int"/></f></getDay>
		<toString public="1" set="method" line="73"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="32"><f a="year:month:day:hour:min:sec">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="ValueType" params="" file="/opt/haxe/std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
		<haxe_doc>
	The diffent possible runtime types of a value.
	See [Type] for the haXe Reflection API.
</haxe_doc>
	</enum>
	<class path="Type" params="" file="/opt/haxe/std/Type.hx">
		<getClass public="1" params="T" set="method" line="26" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="89" static="1">
			<f a="o">
				<d/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="129" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="152" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="177" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="194" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="256" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="313" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="365" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="421" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="442" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="467" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="516" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="559" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="580" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="703" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="775" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="790" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="810" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="php.PhpMath__" params="" file="/opt/haxe/std/php/PhpMath__.hx">
		<PI public="1" static="1"><unknown/></PI>
		<NaN public="1" static="1"><unknown/></NaN>
		<POSITIVE_INFINITY public="1" static="1"><c path="Int"/></POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" static="1"><c path="Int"/></NEGATIVE_INFINITY>
		<abs public="1" set="method" line="34" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></abs>
		<min public="1" set="method" line="35" static="1"><f a="a:b">
	<unknown/>
	<unknown/>
	<unknown/>
</f></min>
		<max public="1" set="method" line="36" static="1"><f a="a:b">
	<unknown/>
	<unknown/>
	<unknown/>
</f></max>
		<sin public="1" set="method" line="37" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></sin>
		<cos public="1" set="method" line="38" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></cos>
		<atan2 public="1" set="method" line="39" static="1"><f a="y:x">
	<unknown/>
	<unknown/>
	<unknown/>
</f></atan2>
		<tan public="1" set="method" line="40" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></tan>
		<exp public="1" set="method" line="41" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></exp>
		<log public="1" set="method" line="42" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></log>
		<sqrt public="1" set="method" line="43" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></sqrt>
		<round public="1" set="method" line="44" static="1"><f a="v">
	<c path="Float"/>
	<unknown/>
</f></round>
		<floor public="1" set="method" line="45" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></floor>
		<ceil public="1" set="method" line="46" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></ceil>
		<atan public="1" set="method" line="47" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></atan>
		<asin public="1" set="method" line="48" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></asin>
		<acos public="1" set="method" line="49" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></acos>
		<pow public="1" set="method" line="50" static="1"><f a="b:e">
	<unknown/>
	<unknown/>
	<unknown/>
</f></pow>
		<random public="1" set="method" line="51" static="1"><f a=""><unknown/></f></random>
		<isNaN public="1" set="method" line="52" static="1"><f a="f">
	<unknown/>
	<unknown/>
</f></isNaN>
		<isFinite public="1" set="method" line="53" static="1"><f a="f">
	<unknown/>
	<unknown/>
</f></isFinite>
	</class>
	<class path="Class" params="T" file="/opt/haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="String" params="" file="/opt/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<cca set="method"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></cca>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="haxe.Md5" params="" file="/opt/haxe/std/haxe/Md5.hx">
		<encode public="1" set="method" line="32" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<haxe_doc>
	Creates a MD5 of a String.
</haxe_doc>
	</class>
	<class path="Array" params="T" file="/opt/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/opt/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="php.Exception" params="" file="/opt/haxe/std/php/Exception.hx" extern="1">
		<message><c path="String"/></message>
		<code><c path="Int"/></code>
		<file><c path="String"/></file>
		<line><c path="Int"/></line>
		<getMessage public="1" set="method"><f a=""><c path="String"/></f></getMessage>
		<getCode public="1" set="method"><f a=""><c path="Int"/></f></getCode>
		<getFile public="1" set="method"><f a=""><c path="String"/></f></getFile>
		<getLine public="1" set="method"><f a=""><c path="Int"/></f></getLine>
		<getTrace public="1" set="method"><f a=""><c path="Array"><c path="String"/></c></f></getTrace>
		<getTraceAsString public="1" set="method"><f a=""><c path="String"/></f></getTraceAsString>
		<__toString public="1" set="method"><f a=""><c path="String"/></f></__toString>
		<new public="1" set="method"><f a="?message:?code">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="@Main" params="" file=""><init line="1" static="1"><e path="Void"/></init></class>
</haxe>