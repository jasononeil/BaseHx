<haxe>
	<class path="Enum" params="T" file="/usr/share/haxe/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="haxe.xml._Fast.NodeAccess" params="" file="/usr/share/haxe/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="35"><f a="name">
	<c path="String"/>
	<c path="haxe.xml.Fast"/>
</f></resolve>
		<new public="1" set="method" line="31"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="haxe.xml.Fast"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.AttribAccess" params="" file="/usr/share/haxe/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="54"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></resolve>
		<new public="1" set="method" line="50"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="String"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasAttribAccess" params="" file="/usr/share/haxe/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="73"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></resolve>
		<new public="1" set="method" line="69"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><e path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.HasNodeAccess" params="" file="/usr/share/haxe/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="89"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></resolve>
		<new public="1" set="method" line="85"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><e path="Bool"/></haxe_dynamic>
	</class>
	<class path="haxe.xml._Fast.NodeListAccess" params="" file="/usr/share/haxe/haxe/xml/Fast.hx" private="1" module="haxe.xml.Fast">
		<__x><c path="Xml"/></__x>
		<resolve public="1" set="method" line="103"><f a="name">
	<c path="String"/>
	<c path="List"><c path="haxe.xml.Fast"/></c>
</f></resolve>
		<new public="1" set="method" line="99"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="List"><c path="haxe.xml.Fast"/></c></haxe_dynamic>
	</class>
	<class path="haxe.xml.Fast" params="" file="/usr/share/haxe/haxe/xml/Fast.hx">
		<x public="1" set="null"><c path="Xml"/></x>
		<name public="1" get="getName" set="null"><c path="String"/></name>
		<innerData public="1" get="getInnerData" set="null"><c path="String"/></innerData>
		<innerHTML public="1" get="getInnerHTML" set="null"><c path="String"/></innerHTML>
		<node public="1" set="null"><c path="haxe.xml._Fast.NodeAccess"/></node>
		<nodes public="1" set="null"><c path="haxe.xml._Fast.NodeListAccess"/></nodes>
		<att public="1" set="null"><c path="haxe.xml._Fast.AttribAccess"/></att>
		<has public="1" set="null"><c path="haxe.xml._Fast.HasAttribAccess"/></has>
		<hasNode public="1" set="null"><c path="haxe.xml._Fast.HasNodeAccess"/></hasNode>
		<elements public="1" get="getElements" set="null"><t path="Iterator"><c path="haxe.xml.Fast"/></t></elements>
		<getName set="method" line="136"><f a=""><c path="String"/></f></getName>
		<getInnerData set="method" line="140"><f a=""><c path="String"/></f></getInnerData>
		<getInnerHTML set="method" line="152"><f a=""><c path="String"/></f></getInnerHTML>
		<getElements set="method" line="159"><f a=""><a>
	<next><f a=""><c path="haxe.xml.Fast"/></f></next>
	<hasNext><f a=""><e path="Bool"/></f></hasNext>
</a></f></getElements>
		<new public="1" set="method" line="125"><f a="x">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="EReg" params="" file="/usr/share/haxe/EReg.hx">
		<r><d/></r>
		<last><c path="String"/></last>
		<global><e path="Bool"/></global>
		<pattern><c path="String"/></pattern>
		<options><c path="String"/></options>
		<re><c path="String"/></re>
		<matches><c path="ArrayAccess"><d/></c></matches>
		<match public="1" set="method" line="85">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the regular expression matches the String.
		Updates the internal state accordingly.
	</haxe_doc>
		</match>
		<matched public="1" set="method" line="125">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.
	</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="152">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was as the left of
		of the matched substring.
	</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="178">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was at the right of
		of the matched substring.
	</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="210">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>
		Returns the position of the matched substring within the
		original matched string.
	</haxe_doc>
		</matchedPos>
		<split public="1" set="method" line="230">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split a string by using the regular expression to match
		the separators.
	</haxe_doc>
		</split>
		<replace public="1" set="method" line="273">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.
	</haxe_doc>
		</replace>
		<customReplace public="1" set="method" line="339">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>
		For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.
	</haxe_doc>
		</customReplace>
		<new public="1" set="method" line="52">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new regular expression with pattern [r] and
		options [opt].
	</haxe_doc>
		</new>
		<haxe_doc>
	Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.
</haxe_doc>
	</class>
	<class path="php.PhpXml__" params="" file="/usr/share/haxe/php/PhpXml__.hx">
		<Element public="1" set="null" static="1"><e path="XmlType"/></Element>
		<PCData public="1" set="null" static="1"><e path="XmlType"/></PCData>
		<CData public="1" set="null" static="1"><e path="XmlType"/></CData>
		<Comment public="1" set="null" static="1"><e path="XmlType"/></Comment>
		<DocType public="1" set="null" static="1"><e path="XmlType"/></DocType>
		<Prolog public="1" set="null" static="1"><e path="XmlType"/></Prolog>
		<Document public="1" set="null" static="1"><e path="XmlType"/></Document>
		<build static="1"><c path="php.PhpXml__"/></build>
		<__start_element_handler set="method" line="50" static="1"><f a="parser:name:attribs">
	<d/>
	<c path="String"/>
	<c path="ArrayAccess"><c path="String"/></c>
	<e path="Void"/>
</f></__start_element_handler>
		<__end_element_handler set="method" line="57" static="1"><f a="parser:name">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></__end_element_handler>
		<__character_data_handler set="method" line="61" static="1"><f a="parser:data">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></__character_data_handler>
		<__default_handler set="method" line="73" static="1"><f a="parser:data">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></__default_handler>
		<xmlChecker line="77" static="1"><c path="EReg"/></xmlChecker>
		<parse public="1" set="method" line="79" static="1"><f a="str">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></parse>
		<createElement public="1" set="method" line="112" static="1"><f a="name">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createElement>
		<createPCData public="1" set="method" line="121" static="1"><f a="data">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createPCData>
		<createCData public="1" set="method" line="128" static="1"><f a="data">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createCData>
		<createComment public="1" set="method" line="135" static="1"><f a="data">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createComment>
		<createDocType public="1" set="method" line="142" static="1"><f a="data">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createDocType>
		<createProlog public="1" set="method" line="149" static="1"><f a="data">
	<c path="String"/>
	<c path="php.PhpXml__"/>
</f></createProlog>
		<createDocument public="1" set="method" line="156" static="1"><f a=""><c path="php.PhpXml__"/></f></createDocument>
		<nodeType public="1" set="null"><e path="XmlType"/></nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName"><c path="String"/></nodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue"><c path="String"/></nodeValue>
		<parent public="1" get="getParent" set="null"><c path="php.PhpXml__"/></parent>
		<_nodeName public="1"><c path="String"/></_nodeName>
		<_nodeValue public="1"><c path="String"/></_nodeValue>
		<_attributes public="1"><c path="Hash"><c path="String"/></c></_attributes>
		<_children public="1"><c path="Array"><c path="php.PhpXml__"/></c></_children>
		<_parent public="1"><c path="php.PhpXml__"/></_parent>
		<getNodeName set="method" line="163"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName set="method" line="169"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeValue set="method" line="175"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue set="method" line="181"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getParent set="method" line="187"><f a=""><c path="php.PhpXml__"/></f></getParent>
		<get public="1" set="method" line="191"><f a="att">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<set public="1" set="method" line="197"><f a="att:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></set>
		<remove public="1" set="method" line="203"><f a="att">
	<c path="String"/>
	<e path="Void"/>
</f></remove>
		<exists public="1" set="method" line="209"><f a="att">
	<c path="String"/>
	<e path="Bool"/>
</f></exists>
		<attributes public="1" set="method" line="215"><f a=""><t path="Iterator"><c path="String"/></t></f></attributes>
		<iterator public="1" set="method" line="221"><f a=""><t path="Iterator"><c path="php.PhpXml__"/></t></f></iterator>
		<elements public="1" set="method" line="238"><f a=""><t path="Iterator"><c path="php.PhpXml__"/></t></f></elements>
		<elementsNamed public="1" set="method" line="274"><f a="name">
	<c path="String"/>
	<t path="Iterator"><c path="php.PhpXml__"/></t>
</f></elementsNamed>
		<firstChild public="1" set="method" line="311"><f a=""><c path="php.PhpXml__"/></f></firstChild>
		<firstElement public="1" set="method" line="317"><f a=""><c path="php.PhpXml__"/></f></firstElement>
		<addChild public="1" set="method" line="330"><f a="x">
	<c path="php.PhpXml__"/>
	<e path="Void"/>
</f></addChild>
		<removeChild public="1" set="method" line="337"><f a="x">
	<c path="php.PhpXml__"/>
	<e path="Bool"/>
</f></removeChild>
		<insertChild public="1" set="method" line="345"><f a="x:pos">
	<c path="php.PhpXml__"/>
	<c path="Int"/>
	<e path="Void"/>
</f></insertChild>
		<toString public="1" set="method" line="352"><f a=""><c path="String"/></f></toString>
		<new set="method" line="110"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/share/haxe/haxe/io/BytesBuffer.hx">
		<b><c path="String"/></b>
		<addByte public="1" get="inline" set="null" line="55"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<add public="1" get="inline" set="null" line="69"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addBytes public="1" get="inline" set="null" line="84"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="106">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>
		Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.
	</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="41"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.io.Input" params="" file="/usr/share/haxe/haxe/io/Input.hx">
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<readByte public="1" set="method" line="35"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="44"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="65"><f a=""><e path="Void"/></f></close>
		<setEndian set="method" line="68"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<readAll public="1" set="method" line="75"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<readFullBytes public="1" set="method" line="96"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<read public="1" set="method" line="104"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readUntil public="1" set="method" line="116"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<readLine public="1" set="method" line="124"><f a=""><c path="String"/></f></readLine>
		<readFloat public="1" set="method" line="141"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="155"><f a=""><c path="Float"/></f></readDouble>
		<readInt8 public="1" set="method" line="169"><f a=""><c path="Int"/></f></readInt8>
		<readInt16 public="1" set="method" line="176"><f a=""><c path="Int"/></f></readInt16>
		<readUInt16 public="1" set="method" line="185"><f a=""><c path="Int"/></f></readUInt16>
		<readInt24 public="1" set="method" line="191"><f a=""><c path="Int"/></f></readInt24>
		<readUInt24 public="1" set="method" line="201"><f a=""><c path="Int"/></f></readUInt24>
		<readInt31 public="1" set="method" line="208"><f a=""><c path="Int"/></f></readInt31>
		<readUInt30 public="1" set="method" line="225"><f a=""><c path="Int"/></f></readUInt30>
		<readInt32 public="1" set="method" line="234"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readString public="1" set="method" line="242"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>
	An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.
</haxe_doc>
	</class>
	<class path="php.db.Connection" params="" file="/usr/share/haxe/php/db/Connection.hx" interface="1">
		<request public="1" set="method"><f a="s">
	<c path="String"/>
	<c path="php.db.ResultSet"/>
</f></request>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<escape public="1" set="method"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></escape>
		<quote public="1" set="method"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></quote>
		<addValue public="1" set="method"><f a="s:v">
	<c path="StringBuf"/>
	<d/>
	<e path="Void"/>
</f></addValue>
		<lastInsertId public="1" set="method"><f a=""><c path="Int"/></f></lastInsertId>
		<dbName public="1" set="method"><f a=""><c path="String"/></f></dbName>
		<startTransaction public="1" set="method"><f a=""><e path="Void"/></f></startTransaction>
		<commit public="1" set="method"><f a=""><e path="Void"/></f></commit>
		<rollback public="1" set="method"><f a=""><e path="Void"/></f></rollback>
	</class>
	<class path="basehx.BaseController" params="" file="src/basehx/BaseController.hx">
		<aliases public="1" line="37" static="1">
			<c path="Array"><unknown/></c>
			<haxe_doc> Create a static array "aliases" with any alternate URL requests
	that you want to point to this controller.  </haxe_doc>
		</aliases>
		<isCacheable public="1" set="null">
			<e path="Bool"/>
			<haxe_doc> Can this controller be cached?  (Read only)
	In your Controller Class definition, set this to true or false </haxe_doc>
		</isCacheable>
		<actions><c path="Hash"><c path="String"/></c></actions>
		<output><c path="String"/></output>
		<view>
			<c path="basehx.tpl.HxTpl"/>
			<haxe_doc> View is the bit of the template specific to this action </haxe_doc>
		</view>
		<template>
			<c path="basehx.tpl.HxTpl"/>
			<haxe_doc> Template is the overall HTML of the page.  Either a site wide 
	or controller wide template.  </haxe_doc>
		</template>
		<pageTemplateFile>
			<c path="String"/>
			<haxe_doc><![CDATA[ If all your actions in this controller sit inside a specific
	template, add this template here.  The specific actions will show
	up inside the &gthxInclude name="content">.  If you do use a 
	pageTemplateFile, you can initialise it (assign values, loops,
	other includes etc) in the initiatePageTemplate() function, which
	you override for your controller.  ]]></haxe_doc>
		</pageTemplateFile>
		<initiatePageTemplate set="method" line="29"><f a=""><e path="Void"/></f></initiatePageTemplate>
		<getDefaultAction public="1" set="method" line="95">
			<f a=""><f a=""><e path="Void"/></f></f>
			<haxe_doc> Override this method to set your default action.  
	Your override method should call:
	
	super.defaultAction(args,"myDefaultAction");
	
	or something like that.</haxe_doc>
		</getDefaultAction>
		<loadTemplate set="method" line="104">
			<f a="?str:?pos">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Load the template.  Either pass the file path to load,
	or else use convention (views/controller/action.tpl).
	This may have to be re-thought if we want to allow loading
	templates from databases. </haxe_doc>
		</loadTemplate>
		<printTemplate set="method" line="149"><f a=""><e path="Void"/></f></printTemplate>
		<toString public="1" set="method" line="167">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[ The toString() method should give the output from the various
	actions we've called.  This means elsewhere you'll be able to use:
	<pre>	myController = new MyController(args);
	php.Lib.print(myController);</pre>
	to print all the output.]]></haxe_doc>
		</toString>
		<print set="method" line="173">
			<f a="str">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc> In your methods, use print() to write to the output </haxe_doc>
		</print>
		<clearOutput set="method" line="179">
			<f a=""><e path="Void"/></f>
			<haxe_doc> In your methods, if you want to clear the output, use this </haxe_doc>
		</clearOutput>
		<new public="1" set="method" line="44">
			<f a="args">
				<c path="Array"><c path="String"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc> The new() constructor will probably be called by the Dispatcher
	if it decides this is the Controller to use.  The constructor should
	take the arguments, decide on which "action" (method) should be called,
	and call it.  </haxe_doc>
		</new>
		<haxe_doc>
Your controllers should inherit from this base class.
</haxe_doc>
	</class>
	<class path="AppConfig" params="" file="src/AppConfig.hx">
		<defaultController public="1" line="11" static="1">
			<c path="Class"><d/></c>
			<haxe_doc> Default Controller </haxe_doc>
		</defaultController>
		<baseUrl public="1" line="25" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[ Set this to the base URL of your site, not including a trailing slash.
	
	Examples:
	<ul>
		<li>http://www.mysite.com</li>
		<li>http://www.mysite.com/myapp</li>
	</ul>
	]]></haxe_doc>
		</baseUrl>
		<subDir public="1" line="28" static="1">
			<c path="String"/>
			<haxe_doc> The subdirectory on the server we are in.  No trailing slash </haxe_doc>
		</subDir>
		<baseFilePath public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[ Set this to the base filepath of this app on your server,
	(do not include a trailing slash).
	
	Examples:
	<ul>
		<li>/var/www/html</li>
		<li>/home/website</li>
		<li>/home/website/myapp</li>
	</ul>
	
	<b>This property might not be needed... not sure yet.  
	Remember Haxe's import mechanism is alot nicer than PHPs</b>
	]]></haxe_doc>
		</baseFilePath>
		<dbServer public="1" line="52" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[ The address of the database server.  Usually <i>localhost</i>]]></haxe_doc>
		</dbServer>
		<dbPort public="1" line="55" static="1">
			<c path="Int"/>
			<haxe_doc><![CDATA[ The port of the database server.  Usually <i>3306</i>]]></haxe_doc>
		</dbPort>
		<dbDatabase public="1" line="58" static="1">
			<c path="String"/>
			<haxe_doc> The name of the database to use </haxe_doc>
		</dbDatabase>
		<dbUsername public="1" line="61" static="1">
			<c path="String"/>
			<haxe_doc> The username to use when logging in to the database server </haxe_doc>
		</dbUsername>
		<dbPassword public="1" line="64" static="1">
			<c path="String"/>
			<haxe_doc> The password to use when logging in to the database server </haxe_doc>
		</dbPassword>
		<tablePrefix public="1" static="1">
			<c path="String"/>
			<haxe_doc> If you have multiple apps (or versions of apps) on this database,
	you can specify a table prefix to keep table names from overlapping
	each other.  For example, "myapp1.0_" </haxe_doc>
		</tablePrefix>
		<haxe_doc>
This class contains all the config for your app.
I'm not sure which package this should belong in really...
</haxe_doc>
	</class>
	<class path="basehx.Log" params="" file="src/basehx/Log.hx">
		<log public="1" set="method" line="7" static="1">
			<f a="type:msg:pos">
				<e path="basehx.LogType"/>
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc> This is not made to be called directly.  
	Use trace, info, warning or error instead. </haxe_doc>
		</log>
		<trace public="1" set="method" line="19" static="1"><f a="v:?pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<info public="1" set="method" line="24" static="1"><f a="info:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></info>
		<warning public="1" set="method" line="29" static="1"><f a="warning:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></warning>
		<error public="1" set="method" line="34" static="1"><f a="error:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></error>
		<assert public="1" set="method" line="40" static="1"><f a="cond:?desc:?pos">
	<e path="Bool"/>
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></assert>
	</class>
	<enum path="basehx.LogType" params="" file="src/basehx/Log.hx" module="basehx.Log">
		<Warning/>
		<Trace/>
		<Info/>
		<Error/>
		<AssertionFailed/>
	</enum>
	<class path="php.Sys" params="" file="/usr/share/haxe/php/Sys.hx">
		<args public="1" set="method" line="5" static="1"><f a=""><c path="Array"><c path="String"/></c></f></args>
		<getEnv public="1" set="method" line="9" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></getEnv>
		<putEnv public="1" set="method" line="13" static="1"><f a="s:v">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></putEnv>
		<sleep public="1" set="method" line="17" static="1"><f a="seconds">
	<c path="Float"/>
	<unknown/>
</f></sleep>
		<setTimeLocale public="1" set="method" line="21" static="1"><f a="loc">
	<c path="String"/>
	<e path="Bool"/>
</f></setTimeLocale>
		<getCwd public="1" set="method" line="25" static="1"><f a=""><c path="String"/></f></getCwd>
		<setCwd public="1" set="method" line="31" static="1"><f a="s">
	<c path="String"/>
	<unknown/>
</f></setCwd>
		<systemName public="1" set="method" line="35" static="1"><f a=""><c path="String"/></f></systemName>
		<escapeArgument public="1" set="method" line="44" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" set="method" line="58" static="1"><f a="cmd:?args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="Int"/>
</f></command>
		<exit public="1" set="method" line="71" static="1"><f a="code">
	<c path="Int"/>
	<unknown/>
</f></exit>
		<time public="1" set="method" line="75" static="1"><f a=""><c path="Float"/></f></time>
		<cpuTime public="1" set="method" line="79" static="1"><f a=""><c path="Float"/></f></cpuTime>
		<executablePath public="1" set="method" line="83" static="1"><f a=""><c path="String"/></f></executablePath>
		<environment public="1" set="method" line="87" static="1"><f a=""><c path="Hash"><c path="String"/></c></f></environment>
	</class>
	<class path="MainApp" params="" file="src/MainApp.hx">
		<startTime public="1" line="9" static="1"><c path="Float"/></startTime>
		<main public="1" set="method" line="11" static="1"><f a=""><e path="Void"/></f></main>
		<pageTemplateFile public="1" set="null" static="1">
			<c path="String"/>
			<haxe_doc> This allows you to set a site-wide HTML template for your App.
	You can also set a template for each controller, but if that is not
	there it will full back to this.  Should this stuff be kept in
	AppConfig instead?    </haxe_doc>
		</pageTemplateFile>
		<initiatePageTemplate public="1" set="method" line="31" static="1"><f a=""><c path="basehx.tpl.HxTpl"/></f></initiatePageTemplate>
		<printStats public="1" set="method" line="38" static="1"><f a=""><e path="Void"/></f></printStats>
	</class>
	<class path="php.NativeArray" params="" file="/usr/share/haxe/php/NativeArray.hx" extern="1"/>
	<class path="php.db._Mysql.MysqlConnection" params="" file="/usr/share/haxe/php/db/Mysql.hx" private="1" module="php.db.Mysql">
		<implements path="php.db.Connection"/>
		<c><e path="Void"/></c>
		<close public="1" set="method" line="37"><f a=""><e path="Void"/></f></close>
		<request public="1" set="method" line="42"><f a="s">
	<c path="String"/>
	<c path="php.db.ResultSet"/>
</f></request>
		<escape public="1" set="method" line="49"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></escape>
		<quote public="1" set="method" line="53"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></quote>
		<addValue public="1" set="method" line="57"><f a="s:v">
	<c path="StringBuf"/>
	<d/>
	<e path="Void"/>
</f></addValue>
		<lastInsertId public="1" set="method" line="66"><f a=""><c path="Int"/></f></lastInsertId>
		<dbName public="1" set="method" line="70"><f a=""><c path="String"/></f></dbName>
		<startTransaction public="1" set="method" line="74"><f a=""><e path="Void"/></f></startTransaction>
		<commit public="1" set="method" line="78"><f a=""><e path="Void"/></f></commit>
		<rollback public="1" set="method" line="82"><f a=""><e path="Void"/></f></rollback>
		<new public="1" set="method" line="33"><f a="c">
	<e path="Void"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="php.db.ResultSet" params="" file="/usr/share/haxe/php/db/ResultSet.hx" interface="1">
		<length public="1" get="getLength" set="null"><c path="Int"/></length>
		<nfields public="1" get="getNFields" set="null"><c path="Int"/></nfields>
		<hasNext public="1" set="method"><f a=""><e path="Bool"/></f></hasNext>
		<next public="1" set="method"><f a=""><d/></f></next>
		<results public="1" set="method"><f a=""><c path="List"><d/></c></f></results>
		<getResult public="1" set="method"><f a="n">
	<c path="Int"/>
	<c path="String"/>
</f></getResult>
		<getIntResult public="1" set="method"><f a="n">
	<c path="Int"/>
	<c path="Int"/>
</f></getIntResult>
		<getFloatResult public="1" set="method"><f a="n">
	<c path="Int"/>
	<c path="Float"/>
</f></getFloatResult>
	</class>
	<class path="php.db._Mysql.MysqlResultSet" params="" file="/usr/share/haxe/php/db/Mysql.hx" private="1" module="php.db.Mysql">
		<implements path="php.db.ResultSet"/>
		<length public="1" get="getLength" set="null"><c path="Int"/></length>
		<nfields public="1" get="getNFields" set="null"><c path="Int"/></nfields>
		<__r><e path="Void"/></__r>
		<__c><e path="Void"/></__c>
		<cache><d/></cache>
		<getLength set="method" line="100"><f a=""><c path="Int"/></f></getLength>
		<_nfields><c path="Int"/></_nfields>
		<getNFields set="method" line="109"><f a=""><c path="Int"/></f></getNFields>
		<_fieldsDesc><c path="Array"><d/></c></_fieldsDesc>
		<getFieldsDescription set="method" line="116"><f a=""><c path="Array"><d/></c></f></getFieldsDescription>
		<convert set="method" line="130"><f a="v:type">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></convert>
		<hasNext public="1" set="method" line="144"><f a=""><e path="Bool"/></f></hasNext>
		<cRow><c path="ArrayAccess"><c path="String"/></c></cRow>
		<fetchRow set="method" line="151"><f a=""><e path="Bool"/></f></fetchRow>
		<next public="1" set="method" line="156"><f a=""><d/></f></next>
		<results public="1" set="method" line="171"><f a=""><c path="List"><d/></c></f></results>
		<getResult public="1" set="method" line="178"><f a="n">
	<c path="Int"/>
	<c path="String"/>
</f></getResult>
		<getIntResult public="1" set="method" line="185"><f a="n">
	<c path="Int"/>
	<c path="Int"/>
</f></getIntResult>
		<getFloatResult public="1" set="method" line="189"><f a="n">
	<c path="Int"/>
	<c path="Float"/>
</f></getFloatResult>
		<new public="1" set="method" line="95"><f a="r:c">
	<e path="Void"/>
	<e path="Void"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="php.db.Mysql" params="" file="/usr/share/haxe/php/db/Mysql.hx"><connect public="1" set="method" line="196" static="1"><f a="params">
	<a>
		<user><c path="String"/></user>
		<socket><c path="String"/></socket>
		<port><c path="Int"/></port>
		<pass><c path="String"/></pass>
		<host><c path="String"/></host>
		<database><c path="String"/></database>
	</a>
	<c path="php.db.Connection"/>
</f></connect></class>
	<class path="StringTools" params="" file="/usr/share/haxe/StringTools.hx">
		<urlEncode public="1" get="inline" set="null" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" get="inline" set="null" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" get="inline" set="null" line="87" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="98" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="105" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="114" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" get="inline" set="null" line="122" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" get="inline" set="null" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" get="inline" set="null" line="161" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" get="inline" set="null" line="172" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" get="inline" set="null" line="194" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" get="inline" set="null" line="219" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" set="method" line="230" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<enum path="XmlType" params="" file="/usr/share/haxe/Xml.hx" module="Xml"><haxe_doc>
	An abstract type representing the type of the Xml
	Node. You can compare it to [Xml] statics and can
	use [Std.string(t)] to get a string reprensation
	of the type.
</haxe_doc></enum>
	<class path="Xml" params="" file="/usr/share/haxe/Xml.hx" extern="1">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Document>
		<parse public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Parse a String into an Xml object.
	</haxe_doc>
		</parse>
		<createElement public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createElement>
		<createPCData public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createPCData>
		<createCData public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createCData>
		<createComment public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createComment>
		<createDocType public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocType>
		<createProlog public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createProlog>
		<createDocument public="1" set="method" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>
		Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.
	</haxe_doc>
		</nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>
		Returns the node name of an Element.
	</haxe_doc>
		</nodeName>
		<getNodeName set="method"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>
		Returns the node value. Only works if the Xml node is not an Element or a Document.
	</haxe_doc>
		</nodeValue>
		<getNodeValue set="method"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue set="method"><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<get public="1" set="method">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.
	</haxe_doc>
		</get>
		<set public="1" set="method">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the given attribute value for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</set>
		<remove public="1" set="method">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Removes an attribute for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</remove>
		<exists public="1" set="method">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the Element node has a given attribute.
		Attributes are case-sensitive.
	</haxe_doc>
		</exists>
		<attributes public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an [Iterator] on all the attributes values.
	</haxe_doc>
		</attributes>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>
		Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.
	</haxe_doc>
		</parent>
		<getParent set="method"><f a=""><c path="Xml"/></f></getParent>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</iterator>
		<elements public="1" set="method">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elements>
		<elementsNamed public="1" set="method">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elementsNamed>
		<firstChild public="1" set="method">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node.
	</haxe_doc>
		</firstChild>
		<firstElement public="1" set="method">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node which is an Element.
	</haxe_doc>
		</firstElement>
		<addChild public="1" set="method">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.
	</haxe_doc>
		</addChild>
		<removeChild public="1" set="method">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.
	</haxe_doc>
		</removeChild>
		<insertChild public="1" set="method">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts a child at the given position among the other childs.
	</haxe_doc>
		</insertChild>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a String representation of the Xml node.
	</haxe_doc>
		</toString>
		<haxe_doc>
	The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.
</haxe_doc>
	</class>
	<class path="Reflect" params="" file="/usr/share/haxe/Reflect.hx">
		<hasField public="1" get="inline" set="null" line="35" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" set="method" line="61" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="87" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" set="method" line="106" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="135" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="210" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="231" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="243" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
		Does not work on Neko platform.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="275" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="319" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="349" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="372" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="php.IteratorAggregate" params="T" file="/usr/share/haxe/php/IteratorAggregate.hx" extern="1" interface="1"><getIterator set="method">
	<f a=""><t path="Iterator"><c path="php.IteratorAggregate.T"/></t></f>
	<haxe_doc> 
		This method is not public to not induce haXe users to use it ;) 
		Use iterator() instead.
		The return type would be Aggregator that is unusable in haXe 
	</haxe_doc>
</getIterator></class>
	<class path="List" params="T" file="/usr/share/haxe/List.hx">
		<implements path="php.IteratorAggregate"><c path="List.T"/></implements>
		<h><c path="ArrayAccess"><d/></c></h>
		<q><c path="ArrayAccess"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" set="method" line="56">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" set="method" line="76">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" set="method" line="100">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" set="method" line="108">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" set="method" line="118">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="132">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" set="method" line="149">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" set="method" line="190">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="215">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" set="method" line="235">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" set="method" line="254">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="270">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<getIterator set="method" line="285">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Implement IteratorAggregate for native php iteration
	</haxe_doc>
		</getIterator>
		<new public="1" set="method" line="49">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<class path="basehx.xml.XmlList" params="" file="src/basehx/xml/XmlList.hx">
		<extends path="List"><c path="basehx.xml.XmlNode"/></extends>
		<addList public="1" set="method" line="43">
			<f a="listToAdd">
				<c path="List"><c path="basehx.xml.XmlNode"/></c>
				<c path="basehx.xml.XmlList"/>
			</f>
			<haxe_doc><![CDATA[
	Append an existing XmlList to this XmlList.
	
	Parameters:
		The child object to add. 
	
	Returns:
		<b>this</b>, the parent object, so we can chain 
		               methods together. 
	]]></haxe_doc>
		</addList>
		<filterByFunction public="1" set="method" line="56">
			<f a="f">
				<f a="">
					<c path="basehx.xml.XmlNode"/>
					<e path="Bool"/>
				</f>
				<c path="basehx.xml.XmlList"/>
			</f>
			<haxe_doc>
	Filter this list by a function.  
	The function should take an XmlNode and return true/false.
	</haxe_doc>
		</filterByFunction>
		<filterByAttribute public="1" set="method" line="69">
			<f a="attName:attValue">
				<c path="String"/>
				<c path="String"/>
				<c path="basehx.xml.XmlList"/>
			</f>
			<haxe_doc>
	Return a subset of this list containing only nodes that have the matching attribute
	
	You could possibly do regexp matches here, just check for a string that's "~/something/"
	</haxe_doc>
		</filterByAttribute>
		<filterByTagName public="1" set="method" line="80">
			<f a="tagName">
				<c path="String"/>
				<c path="basehx.xml.XmlList"/>
			</f>
			<haxe_doc>
	Return a subset of this list containing only elements with this name
	</haxe_doc>
		</filterByTagName>
		<getAt public="1" set="method" line="96">
			<f a="index">
				<c path="Int"/>
				<c path="basehx.xml.XmlNode"/>
			</f>
			<haxe_doc>
	Get the XmlNode at a specific index (0 based, I believe)
	</haxe_doc>
		</getAt>
		<indexOf public="1" set="method" line="126"><f a="childToSearchFor">
	<c path="basehx.xml.XmlNode"/>
	<c path="Int"/>
</f></indexOf>
		<toString public="1" set="method" line="191" override="1"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="15">
			<f a="?node:?list">
				<c path="basehx.xml.XmlNode"/>
				<c path="basehx.xml.XmlList"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	New Constructor that allows us to create an empty list, create one with one XmlNode element, or clone an existing list
	</haxe_doc>
		</new>
		<haxe_doc><![CDATA[
A flat list of XmlNode objects.  Basically just List<XmlNode>, but with
the same functions as XmlNode, which will now apply to all items in the
list.  Pretty neato hey!
*********************************************************************]]></haxe_doc>
	</class>
	<class path="haxe.Log" params="" file="/usr/share/haxe/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="43" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<class path="controllers.ControllerRegistry" params="" file="src/controllers/ControllerRegistry.hx">
		<registerAll public="1" set="method" line="8" static="1"><f a=""><e path="Void"/></f></registerAll>
		<haxe_doc> This whole class is auto-generated from registercontrollers.n in tools. </haxe_doc>
	</class>
	<class path="basehx.tpl.HxTpl" params="" file="src/basehx/tpl/HxTpl.hx">
		<templateString><c path="String"/></templateString>
		<templateXML><c path="basehx.xml.XmlNode"/></templateXML>
		<ready><e path="Bool"/></ready>
		<output><c path="String"/></output>
		<assignedVariables><c path="Hash"><c path="String"/></c></assignedVariables>
		<switches><c path="Hash"><e path="Bool"/></c></switches>
		<loopCount><c path="Hash"><c path="Int"/></c></loopCount>
		<includeURLs><c path="Hash"><c path="String"/></c></includeURLs>
		<blocks><c path="Hash"><c path="basehx.tpl.HxTpl"/></c></blocks>
		<loadTemplateFromString public="1" set="method" line="120">
			<f a="tpl">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>*********************************************************************
	Function: loadTemplateFromString
	************************************************************************
	
	Sets the template to be used for this object, based on a string.  
	This could be based off an included file, a template from a database, 
	a block of an existing template, or user inputted data.  Any valid XML will do.
	
	Parameters:
		tpl:String - The string to use as a template. 
		
	Returns:
		(Bool) Should: True if the template is a valid XML String, 
		  False otherwise.  Reality: Always returns true.
		
	*********************************************************************</haxe_doc>
		</loadTemplateFromString>
		<loadTemplateFromFile public="1" set="method" line="145">
			<f a="url">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>*********************************************************************
	Function: loadTemplateFromFile
	************************************************************************
	
	Loads a template for this object from a file.  
	
	Parameters:
		url:String - The url or path to the root directory for this filesystem
		
	Returns:
		(Bool) Should: True if the template is valid, False otherwise.  
		  Reality: Always returns true.
		
	*********************************************************************</haxe_doc>
		</loadTemplateFromFile>
		<getOutput public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>*********************************************************************
	Function: getOutput
	************************************************************************
	Processes the template and returns a string with the full XML output.
	
	Please note this does not actually print the template to the browser etc. 
	It is up to the class calling the template to take this output and do that.
		
	Returns:
		(String) Full XML Output, the end product of the template
	*********************************************************************</haxe_doc>
		</getOutput>
		<assign public="1" set="method" line="215">
			<f a="name:value:?useHTMLEncode">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
				<c path="basehx.tpl.HxTpl"/>
			</f>
			<haxe_doc><![CDATA[*********************************************************************
	Function: assign
	************************************************************************
	Assign a simple variable name and value.
	An example might be helpful.  If we call
	
	eg - 	my_tpl.assign("title", "Cheesecakes");
	
	Then in the template, any reference to either
	
	eg - 	{title} OR <hxVar name="title">Default Title</hxVar>
	
	Will be replaced with "Cheesecakes".  Simple, no?  
	
	Also, because this object returns itself, statements can be 
	chained together.  
	
	eg -	my_tpl.assign("page", "Five Fruits").assign("url","fruit.html");
	
	Parameters:
		name:String - The name of the template variable we are assigning.
		  You can use Uppercase and Lowercase letters, numbers and 
		  decimal points.
		
		value:String - The text to replace it with.  
		
		useHTMLEncode:Bool - Do we encode this string for HTML?  
		  If *true*, all & < > etc. will be turned into HTML entities.
		  Defaults is *true*
		
	Returns:
		(HxTpl) Returns this template object, so we can chain together 
		assign statements.
	*********************************************************************]]></haxe_doc>
		</assign>
		<assignObject public="1" set="method" line="279">
			<f a="name:obj:?useHTMLEncode">
				<c path="String"/>
				<d/>
				<e path="Bool"/>
				<c path="basehx.tpl.HxTpl"/>
			</f>
			<haxe_doc><![CDATA[*********************************************************************
	Function: assignObject
	************************************************************************
	Assign a simple object containing name value pairs to a template variable.
	An example might be helpful.  If we call
	
	> tpl.assignObject('page', 
	>	{
	>		title		:'New Website',
	>		url		:'http://google.com/myhouse.html'
	>	});
	
	Then they will correspond with atemplate like this -
	
	> title: {page.title}
	> url:   {page.url}
	
	You can also go multiple levels deep.
	
	> tpl.assignObject('page', 
	>	{
	>		url		:'http://google.com/myhouse.html',
	>		urlParts	:
	>				{
	>				protocol : 'http://',
	>				domain : 'google.com',
	>				filename : 'myhouse',
	>				extension : '.html'
	>				}
	>	});
	
	And then access that with
	
	> {page.urlParts.protocol}, {page.urlParts.domain} etc.
	
	As with assign(), assignObject() returns the template object, so you can
	chain together assign commands.
	
	Parameters:
		name:String - The name of the template variable we are assigning.
		  You can use Uppercase and Lowercase letters, numbers and 
		  decimal points.
		
		obj:Dynamic - An object consisting of name:value pairs, possibly
		  multiple levels deep. 
		
		useHTMLEncode:Bool - Do we encode this string for HTML?  
		  If *true*, all & < > etc. will be turned into HTML entities.
		  Defaults is *true*
		
	Returns:
		(HxTpl) Returns this template object, so we can chain together 
		assign statements.
	*********************************************************************]]></haxe_doc>
		</assignObject>
		<setSwitch public="1" set="method" line="366">
			<f a="name:?value">
				<c path="String"/>
				<e path="Bool"/>
				<c path="basehx.tpl.HxTpl"/>
			</f>
			<haxe_doc><![CDATA[*********************************************************************
	Function: setSwitch
	************************************************************************
	
	Define whether a switch will be visible or not.  This returns the block
	inside the switch, so you can assign variables to that block.
	
	Example:
	
	We'll start with this template.
	
	> <h1>Result:</h1>
	> 
	> <p>{message}</p>
	>
	> <hxSwitch name="error">
	>    <p><b>Error:</b> {message}</p>
	> </hxSwitch>
	>
	> <hxSwitch name="theHiddenSection">
	>    The secret of life is something about the number 42
	> </hxSwitch>
	>
	
	Now we run this script.
	
	> var tpl:HxTpl;	// pretend we've loaded the template above
	> tpl.assign("message", "Notice that this message is only affecting the current block, not the block underneath");
	> 
	> var errBlock:HxTpl;
	> errBlock = tpl.setSwitch("error", true);
	> errBlock.assign("message", "The problem is that you're too cool for school.");
	>
	> // if we uncommented the next line, it would show "theHiddenSection"
	> // tpl.setSwitch("theHiddenSection", true);
	
	And it produces this output
	
	> <h1>Result:</h1>
	> 
	> <p>Notice that this message is only affecting the current block, not the block underneath</p>
	>
	> 
	>    <p><b>Error:</b> The problem is that you're too cool for school.</p>
	> 
	
	Parameters:
		name:String - The name of the template switch that we're 
		  looking for.
		
		value:Bool - True to show the switch, false to hide it.  
		
	Returns:
		(HxTpl) Returns a template object of the switch template block, 
		so we can assign variables specifically for the switch.
	*********************************************************************]]></haxe_doc>
		</setSwitch>
		<newLoop public="1" set="method" line="396">
			<f a="name">
				<c path="String"/>
				<c path="basehx.tpl.HxTpl"/>
			</f>
			<haxe_doc>*********************************************************************
	Function: newLoop
	************************************************************************
	
	Create a new instance of a template loop (hxLoop).  No examples yet 
	sorry, though it should work mostly as you'd expect.
	
	Parameters:
		name:String - The name of the template loop that we're 
		  looking for.
		
	Returns:
		(HxTpl) Returns a template object of the loop template block, 
		so we can assign variables specifically for this instance
		of the loop.
	*********************************************************************</haxe_doc>
		</newLoop>
		<useListInLoop public="1" set="method" line="444">
			<f a="list:loopName:varName:?useHTMLEncode">
				<c path="List"><d/></c>
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[*********************************************************************
	Function: useListInLoop
	************************************************************************
	
	This is a shortcut to get a list of objects to each have their own 
	template block.
	
	It essentially is just running this code:
	
	> for (obj in list)
	> {
	> 	loopTpl = this.newLoop(loopName);
	> 	loopTpl.assignObject(varName, obj, useHTMLEncode);
	> }
	
	Parameters:
		list:List - A list of objects containing variables to be 
		            assigned.  A new loop will be created for every 
		            item in the list.
		loopName:String - The name of the template loop (hxLoop) to use.
		varName:String - The name of the template variable that the 
		                 object should be assigned to.
		useHTMLEncode:Bool - Use HTML Encoding on the data?
		
	Returns:
		(nothing yet)
	*********************************************************************]]></haxe_doc>
		</useListInLoop>
		<include public="1" set="method" line="458"><f a="name:?url">
	<c path="String"/>
	<c path="String"/>
	<c path="basehx.tpl.HxTpl"/>
</f></include>
		<processXML set="method" line="488"><f a="xmlElement">
	<c path="basehx.xml.XmlNode"/>
	<c path="String"/>
</f></processXML>
		<processXML_element set="method" line="514"><f a="elm">
	<c path="basehx.xml.XmlNode"/>
	<c path="String"/>
</f></processXML_element>
		<processXML_element_regularElement set="method" line="539"><f a="elm">
	<c path="basehx.xml.XmlNode"/>
	<c path="String"/>
</f></processXML_element_regularElement>
		<processXML_element_hxVar set="method" line="564"><f a="elm">
	<c path="basehx.xml.XmlNode"/>
	<c path="String"/>
</f></processXML_element_hxVar>
		<processXML_element_templateBlock set="method" line="592"><f a="elm">
	<c path="basehx.xml.XmlNode"/>
	<c path="String"/>
</f></processXML_element_templateBlock>
		<processXML_element_templateBlock_hxSwitch set="method" line="621"><f a="elm_in:blockName">
	<c path="basehx.xml.XmlNode"/>
	<c path="String"/>
	<c path="String"/>
</f></processXML_element_templateBlock_hxSwitch>
		<processXML_element_templateBlock_hxLoop set="method" line="639"><f a="elm_in:blockName">
	<c path="basehx.xml.XmlNode"/>
	<c path="String"/>
	<c path="String"/>
</f></processXML_element_templateBlock_hxLoop>
		<processXML_element_templateBlock_hxInclude set="method" line="670"><f a="elm_in:blockName">
	<c path="basehx.xml.XmlNode"/>
	<c path="String"/>
	<c path="String"/>
</f></processXML_element_templateBlock_hxInclude>
		<processXML_textnode set="method" line="708"><f a="str_in">
	<c path="String"/>
	<c path="String"/>
</f></processXML_textnode>
		<getBlock set="method" line="727"><f a="name">
	<c path="String"/>
	<c path="basehx.tpl.HxTpl"/>
</f></getBlock>
		<new public="1" set="method" line="83">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[
	 * Constructor. 
	 * 
	 * <p>Initializes the template object</p>
	 ]]></haxe_doc>
		</new>
		<haxe_doc>*********************************************************************
   Class: HxTpl
   Package: jasononeil.tpl   
   
   A very simple templating class that processes live using any string, 
   rather than requiring pre-processing.  This would allow you to load 
   templates from a database, a file, or even user input.
*********************************************************************</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/share/haxe/StringBuf.hx">
		<add public="1" get="inline" set="null" line="48">
			<f a="?x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" get="inline" set="null" line="61">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="79">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" get="inline" set="null" line="95">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="String"/></b>
		<new public="1" set="method" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="php.Boot" params="" file="/usr/share/haxe/php/Boot.hx">
		<qtypes static="1"><c path="Array"><unknown/></c></qtypes>
		<ttypes static="1"><unknown/></ttypes>
		<tpaths static="1"><unknown/></tpaths>
		<skip_constructor line="7" static="1"><e path="Bool"/></skip_constructor>
	</class>
	<class path="haxe.Int32" params="" file="/usr/share/haxe/haxe/Int32.hx">
		<make public="1" get="inline" set="null" line="33" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></make>
		<ofInt public="1" get="inline" set="null" line="41" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ofInt>
		<toInt public="1" get="inline" set="null" line="49" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toInt>
		<toNativeInt public="1" get="inline" set="null" line="62" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toNativeInt>
		<add public="1" get="inline" set="null" line="70" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></add>
		<sub public="1" get="inline" set="null" line="78" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></sub>
		<mul public="1" get="inline" set="null" line="86" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mul>
		<div public="1" get="inline" set="null" line="94" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></div>
		<mod public="1" get="inline" set="null" line="102" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mod>
		<shl public="1" get="inline" set="null" line="110" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shl>
		<shr public="1" get="inline" set="null" line="118" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shr>
		<ushr public="1" get="inline" set="null" line="126" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ushr>
		<and public="1" get="inline" set="null" line="134" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></and>
		<or public="1" get="inline" set="null" line="142" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></or>
		<xor public="1" get="inline" set="null" line="150" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></xor>
		<neg public="1" get="inline" set="null" line="158" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></neg>
		<complement public="1" get="inline" set="null" line="166" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></complement>
		<compare public="1" get="inline" set="null" line="174" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></compare>
	</class>
	<class path="Hash" params="T" file="/usr/share/haxe/Hash.hx">
		<implements path="php.IteratorAggregate"><c path="Hash.T"/></implements>
		<h><c path="ArrayAccess"><c path="Hash.T"/></c></h>
		<set public="1" set="method" line="63">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" set="method" line="80">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" set="method" line="102">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" set="method" line="133">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" set="method" line="165">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="195">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" set="method" line="240">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<getIterator set="method" line="259">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Implement IteratorAggregate for native php iteration
	</haxe_doc>
		</getIterator>
		<new public="1" set="method" line="38">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="basehx.Dispatcher" params="" file="src/basehx/Dispatcher.hx">
		<controllerRegistry line="14" static="1"><c path="Hash"><c path="Class"><d/></c></c></controllerRegistry>
		<dispatch public="1" set="method" line="19" static="1">
			<f a="request">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc> Takes a request query (usually from the URL) decides
	which controller class to use, passing any extra parameters
	to it as necessary. </haxe_doc>
		</dispatch>
		<registerController public="1" set="method" line="66" static="1">
			<f a="url:controller">
				<c path="String"/>
				<c path="Class"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[ Each controller should register itself here.  
	By default, controllers will register a lower-case version of their
	name, without the word controller.  "PeopleController" becomes "people", 
	etc.  Now that controller can be accessed through "http://mysite.com/people/".
	You could add a custom URL scheme by registering your controller again, but
	with a different alias.  Eg. registerController("members", PeopleController)
	would allow you to access the controller at "http://mysite.com/members/" 
	
	<b>This should be done through the <i>aliases</i> array in your controller</b>
	]]></haxe_doc>
		</registerController>
		<getRequestParts set="method" line="71" static="1"><f a="request">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getRequestParts>
		<haxe_doc>
The Dispatcher class is responsible for deciding which
Controller class is being requested and which action 
should be executed.

This class is called on most page requests.  
</haxe_doc>
	</class>
	<class path="basehx.xml.XmlNode" params="" file="src/basehx/xml/XmlNode.hx">
		<xml public="1" get="getter_xml" set="null">
			<c path="Xml"/>
			<haxe_doc> A reference to the internal Xml object we're using.  (Read Only) </haxe_doc>
		</xml>
		<fast public="1" get="getter_fast" set="null">
			<c path="haxe.xml.Fast"/>
			<haxe_doc> A reference to the internal Fast object we're using.  (Read Only) </haxe_doc>
		</fast>
		<name public="1" get="getter_name" set="setter_name">
			<c path="String"/>
			<haxe_doc> The name of the current Element node.  
	  If the node is not an Element, then this will return the node type.</haxe_doc>
		</name>
		<value public="1" get="getter_value" set="setter_value">
			<c path="String"/>
			<haxe_doc> The value of the current node.  
	  Does not work on Document or Element nodes.  </haxe_doc>
		</value>
		<type public="1" get="getter_type" set="null">
			<e path="XmlType"/>
			<haxe_doc>
	  Variable: type
	  (String) The type of the current node.  (Read Only)
	  
	  Will be one of Cdata, PCData, Prolog, DocType, Document, Comment or Element
	</haxe_doc>
		</type>
		<isCData public="1" get="testIsCData" set="null">
			<e path="Bool"/>
			<haxe_doc>
		  Variable: isCData
		  (Bool) Is this a CData node?
		</haxe_doc>
		</isCData>
		<isPCData public="1" get="testIsPCData" set="null">
			<e path="Bool"/>
			<haxe_doc>
		  Variable: isPCData
		  (Bool) Is this a PCData node?
		</haxe_doc>
		</isPCData>
		<isProlog public="1" get="testIsProlog" set="null">
			<e path="Bool"/>
			<haxe_doc>
		  Variable: isProlog
		  (Bool) Is this a Prolog node?
		</haxe_doc>
		</isProlog>
		<isDocType public="1" get="testIsDocType" set="null">
			<e path="Bool"/>
			<haxe_doc>
		  Variable: isDocType
		  (Bool) Is this a DocType node?
		</haxe_doc>
		</isDocType>
		<isDocument public="1" get="testIsDocument" set="null">
			<e path="Bool"/>
			<haxe_doc>
		  Variable: isDocument
		  (Bool) Is this a Document node?
		</haxe_doc>
		</isDocument>
		<isComment public="1" get="testIsComment" set="null">
			<e path="Bool"/>
			<haxe_doc>
		  Variable: isComment
		  (Bool) Is this a Comment node?
		</haxe_doc>
		</isComment>
		<isElement public="1" get="testIsElement" set="null">
			<e path="Bool"/>
			<haxe_doc>
		  Variable: isElement
		  (Bool) Is this a Element node?
		</haxe_doc>
		</isElement>
		<isText public="1" get="testIsText" set="null">
			<e path="Bool"/>
			<haxe_doc>
		  Variable: isText
		  (Bool) Is this a text node, that is, CData OR PCData?
		</haxe_doc>
		</isText>
		<index public="1" get="getter_index" set="null">
			<c path="Int"/>
			<haxe_doc>
	  Variable: index
	  (Int) The index of this node in relation to it's siblings.
	  
	  The first child of a parent has index 1, the last child has index
	  parent.numChildren.  
	  
	  Returns 0 if this object doesn't have a parent.
	</haxe_doc>
		</index>
		<numChildren public="1" get="getter_numChildren" set="null">
			<c path="Int"/>
			<haxe_doc>
	  Variable: numChildren
	  (Int) The number of children this node has.
	  
	  Returns 0 if this object isn't a parent.
	</haxe_doc>
		</numChildren>
		<parent public="1" get="getter_parent" set="null">
			<c path="basehx.xml.XmlNode"/>
			<haxe_doc><![CDATA[
	  Variable: parent
	  (<XmlNode>) Shortcut for this.getParent(); (Read Only)
	]]></haxe_doc>
		</parent>
		<document public="1" get="getter_document" set="null">
			<c path="basehx.xml.XmlNode"/>
			<haxe_doc>
	Get's the root document node.  
	(Not the document element, the node, which the element is contained in)
	</haxe_doc>
		</document>
		<depth public="1" get="getter_depth" set="null">
			<c path="Int"/>
			<haxe_doc>
	Shortcut for this.getDepthFromDocument().  Immediate childs of document node return 1, grandchildren 2, etc.
	</haxe_doc>
		</depth>
		<children public="1" get="getter_children" set="null">
			<c path="basehx.xml.XmlList"/>
			<haxe_doc><![CDATA[
	  Variable: children
	  (<XmlList>) Shortcut for this.getChildren(); (Read Only)
	]]></haxe_doc>
		</children>
		<firstChild public="1" get="getter_firstChild" set="null">
			<c path="basehx.xml.XmlNode"/>
			<haxe_doc><![CDATA[
	  Variable: firstChild
	  (<XmlNode>) Shortcut for this.getFirstChild(); (Read Only)
	]]></haxe_doc>
		</firstChild>
		<lastChild public="1" get="getter_lastChild" set="null">
			<c path="basehx.xml.XmlNode"/>
			<haxe_doc><![CDATA[
	  Variable: lastChild
	  (<XmlNode>) Shortcut for this.getLastChild(); (Read Only)
	]]></haxe_doc>
		</lastChild>
		<ancestors public="1" get="getter_ancestors" set="null">
			<c path="basehx.xml.XmlList"/>
			<haxe_doc><![CDATA[
	  Variable: ancestors
	  (<XmlList>) Shortcut for this.getAncestors(); (Read Only)
	]]></haxe_doc>
		</ancestors>
		<descendants public="1" get="getter_descendants" set="null">
			<c path="basehx.xml.XmlList"/>
			<haxe_doc><![CDATA[
	  Variable: descendants
	  (<XmlList>) Shortcut for this.getDescendants(); (Read Only)
	]]></haxe_doc>
		</descendants>
		<siblings public="1" get="getter_siblings" set="null">
			<c path="basehx.xml.XmlList"/>
			<haxe_doc><![CDATA[
	  Variable: siblings
	  (<XmlList>) Shortcut for this.getSiblings(); (Read Only)
	]]></haxe_doc>
		</siblings>
		<next public="1" get="getter_next" set="null">
			<c path="basehx.xml.XmlNode"/>
			<haxe_doc><![CDATA[
	  Variable: next
	  (<XmlNode>) Shortcut for this.getNext(); (Read Only)
	]]></haxe_doc>
		</next>
		<prev public="1" get="getter_prev" set="null">
			<c path="basehx.xml.XmlNode"/>
			<haxe_doc><![CDATA[
	  Variable: prev
	  (<XmlNode>) Shortcut for this.getPrev(); (Read Only)
	]]></haxe_doc>
		</prev>
		<siblingsBefore public="1" get="getter_siblingsBefore" set="null">
			<c path="basehx.xml.XmlList"/>
			<haxe_doc><![CDATA[
	  Variable: siblingsBefore
	  (<XmlList>) Shortcut for this.getSiblingsBefore(); (Read Only)
	]]></haxe_doc>
		</siblingsBefore>
		<siblingsAfter public="1" get="getter_siblingsAfter" set="null">
			<c path="basehx.xml.XmlList"/>
			<haxe_doc><![CDATA[
	  Variable: siblingsAfter
	  (<XmlList>) Shortcut for this.getSiblingsAfter(); (Read Only)
	]]></haxe_doc>
		</siblingsAfter>
		<innerXML public="1" get="getter_innerXml" set="setter_innerXml">
			<c path="String"/>
			<haxe_doc><![CDATA[
	  Variable: innerXML
	  (String) Gets and sets the inner XML.
	  
	  The innerXML is anything between the main tags.
	  
	  > trace (xml);        	// "&lt;h1&gt;Old &lt;b&gt;Title&lt;/b&gt;&lt;/h1&gt;"
	  > trace (xml.innerHTML);	// "Old &lt;b&gt;Title&lt;/b&gt;"
	  >
	  > xml.innerHTML = "New <i>Title</i>";
	  >
	  > trace (xml);       		// "&lt;h1&gt;New &lt;i&gt;Title&lt;/i&gt;&lt;/h1&gt;"
	  
	]]></haxe_doc>
		</innerXML>
		<outerXML public="1" get="getter_outerXml" set="setter_outerXml">
			<c path="String"/>
			<haxe_doc><![CDATA[
	  Variable: outerXML
	  (String) Gets and sets the outer XML.
	  
	  <pre>
trace (body);           	// "&lt;body&gt;&lt;h1 class="title"&gt;Old Title&lt;/h1&gt;&lt;/body&gt;"
trace (header);         	// "&lt;h1 class="title"&gt;Old Title&lt;/h1&gt;"
trace (header.outerXML);	// "&lt;h1 class="title"&gt;Old Title&lt;/h1&gt;"
header.outerXML = "&lt;header size='1'&gt;New Title&lt;/header&gt;";
trace (xml);       	    	// "&lt;body&gt;&lt;header size='1'&gt;New Title&lt;/header&gt;&lt;/body&gt;"
</pre>
	  
	  Please note that after setting outerXML, this object is no longer useful.
	  There are reasons for this, mainly we don't know how many nodes have been inserted
	  And we can only wrap one at a time, so which one do we choose?
	  
	  You will have to find the object again, like this
	  
	  &gt; header = body.firstChild;
	  &gt; header.outerXML = "&lt;h2&gt;New Header&lt;/h2&gt;";
	  &gt; header = body.firstChild;
	  &gt; header.setAtt("class", "pageHead");
	  
	  I should set it up to latch on to the first child, but haven't done so yet.
	  
	]]></haxe_doc>
		</outerXML>
		<innerText public="1" get="getter_innerText" set="setter_innerXml"><c path="String"/></innerText>
		<x><c path="Xml"/></x>
		<f><c path="haxe.xml.Fast"/></f>
		<copy public="1" set="method" line="406"><f a=""><c path="basehx.xml.XmlNode"/></f></copy>
		<addChildAt public="1" set="method" line="455"><f a="child:?index">
	<c path="basehx.xml.XmlNode"/>
	<c path="Int"/>
	<c path="basehx.xml.XmlNode"/>
</f></addChildAt>
		<appendChild public="1" set="method" line="496"><f a="child">
	<c path="basehx.xml.XmlNode"/>
	<c path="basehx.xml.XmlNode"/>
</f></appendChild>
		<prependChild public="1" set="method" line="522"><f a="child">
	<c path="basehx.xml.XmlNode"/>
	<c path="basehx.xml.XmlNode"/>
</f></prependChild>
		<addChildBefore public="1" set="method" line="548"><f a="newChild:existingChild">
	<c path="basehx.xml.XmlNode"/>
	<c path="basehx.xml.XmlNode"/>
	<c path="basehx.xml.XmlNode"/>
</f></addChildBefore>
		<addChildAfter public="1" set="method" line="575"><f a="newChild:existingChild">
	<c path="basehx.xml.XmlNode"/>
	<c path="basehx.xml.XmlNode"/>
	<c path="basehx.xml.XmlNode"/>
</f></addChildAfter>
		<addThisTo public="1" set="method" line="612"><f a="newParent:?pos">
	<c path="basehx.xml.XmlNode"/>
	<c path="Int"/>
	<c path="basehx.xml.XmlNode"/>
</f></addThisTo>
		<removeChild public="1" set="method" line="658"><f a="child">
	<c path="basehx.xml.XmlNode"/>
	<c path="basehx.xml.XmlNode"/>
</f></removeChild>
		<removeChildAt public="1" set="method" line="685"><f a="pos">
	<c path="Int"/>
	<c path="basehx.xml.XmlNode"/>
</f></removeChildAt>
		<removeChildren public="1" set="method" line="732"><f a="children">
	<c path="basehx.xml.XmlList"/>
	<c path="basehx.xml.XmlNode"/>
</f></removeChildren>
		<clearWhitespace public="1" set="method" line="748">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
	collapseWhitespace() will go through all child text nodes (not descendants yet)
	and delete any whitespace-only nodes.  
	
	Returns the number of nodes deleted in the process.
	</haxe_doc>
		</clearWhitespace>
		<empty public="1" set="method" line="792"><f a=""><c path="basehx.xml.XmlNode"/></f></empty>
		<hasAtt public="1" set="method" line="817"><f a="attName">
	<c path="String"/>
	<e path="Bool"/>
</f></hasAtt>
		<getAtt public="1" set="method" line="831"><f a="attName">
	<c path="String"/>
	<c path="String"/>
</f></getAtt>
		<setAtt public="1" set="method" line="849"><f a="attName:attValue">
	<c path="String"/>
	<c path="String"/>
	<c path="basehx.xml.XmlNode"/>
</f></setAtt>
		<getAttList public="1" set="method" line="858"><f a=""><c path="List"><c path="String"/></c></f></getAttList>
		<getParent public="1" set="method" line="879"><f a=""><c path="basehx.xml.XmlNode"/></f></getParent>
		<getDocument public="1" set="method" line="891"><f a=""><c path="basehx.xml.XmlNode"/></f></getDocument>
		<getDepthFromDocument public="1" set="method" line="909">
			<f a=""><c path="Int"/></f>
			<haxe_doc> Count the depth from the document.  Ie. An immediate child is 1, a granchild is 2 etc. </haxe_doc>
		</getDepthFromDocument>
		<getNthParent public="1" set="method" line="925"><f a="n">
	<c path="Int"/>
	<c path="basehx.xml.XmlNode"/>
</f></getNthParent>
		<getAncestors public="1" set="method" line="931"><f a="?nameFilter:?limit">
	<c path="String"/>
	<c path="Int"/>
	<c path="basehx.xml.XmlList"/>
</f></getAncestors>
		<getChildren public="1" set="method" line="948"><f a="?nameFilter:?limit">
	<c path="String"/>
	<c path="Int"/>
	<c path="basehx.xml.XmlList"/>
</f></getChildren>
		<getChildAt public="1" set="method" line="966"><f a="index">
	<c path="Int"/>
	<c path="basehx.xml.XmlNode"/>
</f></getChildAt>
		<getFirstChild public="1" set="method" line="971"><f a=""><c path="basehx.xml.XmlNode"/></f></getFirstChild>
		<getLastChild public="1" set="method" line="976"><f a=""><c path="basehx.xml.XmlNode"/></f></getLastChild>
		<getDescendants public="1" set="method" line="988">
			<f a=""><c path="basehx.xml.XmlList"/></f>
			<haxe_doc>
	Get all descendants as an XmlList.  
	
	By default this doesn't do any filtering.  
	You can run filters on the resulting XmlList though
	</haxe_doc>
		</getDescendants>
		<getSiblings public="1" set="method" line="1010">
			<f a=""><c path="basehx.xml.XmlList"/></f>
			<haxe_doc>
	Get all Sibling nodes.  This doesn't do any filtering, but you can filter the resulting list though.
	</haxe_doc>
		</getSiblings>
		<getNext public="1" set="method" line="1028"><f a=""><c path="basehx.xml.XmlNode"/></f></getNext>
		<getPrev public="1" set="method" line="1042"><f a=""><c path="basehx.xml.XmlNode"/></f></getPrev>
		<getSiblingsBefore public="1" set="method" line="1056"><f a=""><c path="basehx.xml.XmlList"/></f></getSiblingsBefore>
		<getSiblingsAfter public="1" set="method" line="1076"><f a=""><c path="basehx.xml.XmlList"/></f></getSiblingsAfter>
		<getElementsById public="1" set="method" line="1104">
			<f a="id_in">
				<c path="String"/>
				<c path="basehx.xml.XmlList"/>
			</f>
			<haxe_doc>
	Designed to be like Javascripts document.getElementById();
	
	Will find any child (or descendant) element with an attribute ID that matches.  
	Note this is different to javascript - this will not just give you the first result,
	but will give you all matching results.  If you just want the first one you can use
	
	myElement = getElementById("myID")[0];
	</haxe_doc>
		</getElementsById>
		<getElementsByTagName public="1" set="method" line="1109"><f a="name_in">
	<c path="String"/>
	<c path="basehx.xml.XmlList"/>
</f></getElementsByTagName>
		<compareDocumentPosition public="1" set="method" line="1114"><f a="otherNode">
	<c path="basehx.xml.XmlNode"/>
	<e path="basehx.xml.XmlNodePosition"/>
</f></compareDocumentPosition>
		<isDescendantOf public="1" set="method" line="1180">
			<f a="otherNode">
				<c path="basehx.xml.XmlNode"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
	Test if this is a child of another node.  I'm using this in compareDocumentPosition, but I guess it could be useful for someone else...
	</haxe_doc>
		</isDescendantOf>
		<setInnerXML public="1" set="method" line="1201"><f a="str">
	<c path="String"/>
	<c path="basehx.xml.XmlNode"/>
</f></setInnerXML>
		<setOuterXML public="1" set="method" line="1207"><f a="str">
	<c path="String"/>
	<c path="basehx.xml.XmlNode"/>
</f></setOuterXML>
		<toString public="1" set="method" line="1213"><f a=""><c path="String"/></f></toString>
		<iterator public="1" set="method" line="1218"><f a=""><t path="Iterator"><c path="basehx.xml.XmlNode"/></t></f></iterator>
		<getter_xml set="method" line="1232"><f a=""><c path="Xml"/></f></getter_xml>
		<getter_fast set="method" line="1241"><f a=""><c path="haxe.xml.Fast"/></f></getter_fast>
		<getter_name set="method" line="1250"><f a=""><c path="String"/></f></getter_name>
		<setter_name set="method" line="1255"><f a="newName">
	<c path="String"/>
	<c path="String"/>
</f></setter_name>
		<getter_type set="method" line="1261"><f a=""><e path="XmlType"/></f></getter_type>
		<testIsCData set="method" line="1267"><f a=""><e path="Bool"/></f></testIsCData>
		<testIsComment set="method" line="1268"><f a=""><e path="Bool"/></f></testIsComment>
		<testIsDocType set="method" line="1269"><f a=""><e path="Bool"/></f></testIsDocType>
		<testIsDocument set="method" line="1270"><f a=""><e path="Bool"/></f></testIsDocument>
		<testIsElement set="method" line="1271"><f a=""><e path="Bool"/></f></testIsElement>
		<testIsPCData set="method" line="1272"><f a=""><e path="Bool"/></f></testIsPCData>
		<testIsProlog set="method" line="1273"><f a=""><e path="Bool"/></f></testIsProlog>
		<testIsText set="method" line="1274"><f a=""><e path="Bool"/></f></testIsText>
		<getter_value set="method" line="1276"><f a=""><c path="String"/></f></getter_value>
		<setter_value set="method" line="1283"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setter_value>
		<getter_parent set="method" line="1296"><f a=""><c path="basehx.xml.XmlNode"/></f></getter_parent>
		<getter_document set="method" line="1301"><f a=""><c path="basehx.xml.XmlNode"/></f></getter_document>
		<getter_depth set="method" line="1306"><f a=""><c path="Int"/></f></getter_depth>
		<getter_children set="method" line="1311"><f a=""><c path="basehx.xml.XmlList"/></f></getter_children>
		<getter_firstChild set="method" line="1316"><f a=""><c path="basehx.xml.XmlNode"/></f></getter_firstChild>
		<getter_lastChild set="method" line="1321"><f a=""><c path="basehx.xml.XmlNode"/></f></getter_lastChild>
		<getter_ancestors set="method" line="1326"><f a=""><c path="basehx.xml.XmlList"/></f></getter_ancestors>
		<getter_descendants set="method" line="1331"><f a=""><c path="basehx.xml.XmlList"/></f></getter_descendants>
		<getter_siblings set="method" line="1336"><f a=""><c path="basehx.xml.XmlList"/></f></getter_siblings>
		<getter_next set="method" line="1341"><f a=""><c path="basehx.xml.XmlNode"/></f></getter_next>
		<getter_prev set="method" line="1346"><f a=""><c path="basehx.xml.XmlNode"/></f></getter_prev>
		<getter_siblingsBefore set="method" line="1351"><f a=""><c path="basehx.xml.XmlList"/></f></getter_siblingsBefore>
		<getter_siblingsAfter set="method" line="1356"><f a=""><c path="basehx.xml.XmlList"/></f></getter_siblingsAfter>
		<getter_index set="method" line="1361"><f a=""><c path="Int"/></f></getter_index>
		<getter_numChildren set="method" line="1376"><f a=""><c path="Int"/></f></getter_numChildren>
		<getter_innerXml set="method" line="1381"><f a=""><c path="String"/></f></getter_innerXml>
		<setter_innerXml set="method" line="1386"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></setter_innerXml>
		<getter_outerXml set="method" line="1401"><f a=""><c path="String"/></f></getter_outerXml>
		<setter_outerXml set="method" line="1413"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></setter_outerXml>
		<getter_innerText set="method" line="1453"><f a=""><c path="String"/></f></getter_innerText>
		<new public="1" set="method" line="356">
			<f a="?str_in:?xml_in:?advXmlItem_in">
				<c path="String"/>
				<c path="Xml"/>
				<c path="basehx.xml.XmlNode"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[*********************************************************************
	Constructor: new()
	
	Constructs an XmlNode object.
	
	It can be constructed based on a string, a HaXe Xml object, or an 
	existing XmlNode object.  Please note, the parameters are optional,
	and so you can enter any single one of them, rather than having to 
	remember the order.
	
	It would be nice in this situation to use different constructor methods
	Java style.  Oh well.
	
	Constructing by string:
	
	If you pass the new() constructor a String, it will use Xml.Parse() 
	to create a new set of nodes.  If the stringi s not valid XML, an 
	"Xml parse error" will be thrown, and the script will fail.  (We 
	should probably be a little nicer).
	
	When constructing from a string, a Document node is created.  Any other
	nodes (elements, text nodes, etc) are childs of this document node.
	
	Constructing by Xml object:
	
	If you pass the new() constructor an Xml object, then it wraps this
	with XmlNode functionality.  Please note this will not create a new
	node in the XML document, merely wrap our functionality around an 
	existing node.
	
	Constructing by an existing XmlNode object:
	
	If you pass the new() constructor an existing XmlNode, it will use
	the <XmlNode.copy()> method of the existing object to create the new
	object.
	
	
	
	
	So an example or two:
	
	> // Declare the object we'll be using
	> var objFromString:XmlNode;
	> var objFromXml:XmlNode;
	> var objFromXml:XmlNode;
	>
	> // Initialise the string object
	> objFromString = new XmlNode("<myElement>Hey!</myElement>");
	> trace (objFromString)				// <myElement>Hey!</myElement>
	> trace (objFromString.type)			// Document
	> trace (objFromString.firstChild.type) 	// Element
	> trace (objFromString.firstChild.name) 	// myElement
	>
	> // Then construct from an XML object
	> 
	> // And then from an existing XmlNode object.
	>
	
	Parameters:

		str_in - Initialise an XmlNode object from a string.  
		xml_in - Create a new XmlNode object, based on an existing Xml
		         object.  This won't duplicate the existing node, rather
		         it will wrap the XmlNode functionality around that 
		         node.
		advXmlItem_in - Create a new XmlNode object, copying 
		                an existing object.  This will duplicate the XML
		                node.

	Returns:

		(<XmlNode>) The object that has been created.

	*********************************************************************]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[   
   This class aims to provide a much easier way to navigate and manipulate
   XML in haxe.  This implementation should be platform independent, though
   I haven't done the testing yet.
   
   The idea is, if all platforms can implement the same XML class, then
   the code portability is going to be even higher.  Which is sweet!
   
   I've tried to copy alot of the functionality from libraries like jquery.
   So at the moment most functions return themselves, so they can be chained
   together.  For example:
   
   | bodyElm.setInnerHTML("&lt;h1&gt;Inner HTML of Body&lt;/h1&gt;").firstChild.setAtt("class","Title");
   
   Should produce...
   
   | &lt;body&gt;&lt;h1 class="Title"&gt;Inner HTML of Body&lt;/h1&gt;
]]></haxe_doc>
	</class>
	<enum path="basehx.xml.XmlNodePosition" params="" file="src/basehx/xml/XmlNode.hx" module="basehx.xml.XmlNode">
		<PRECEDING><haxe_doc> The elements either don't belong to the same document or MAYBE are in unrelated parts of the DOM tree </haxe_doc></PRECEDING>
		<FOLLOWING><haxe_doc> The elements are siblings, and this element we're testing against comes after </haxe_doc></FOLLOWING>
		<DISCONNECTED/>
		<CONTAINS><haxe_doc> The elements are siblings, and the element we're testing against comes first </haxe_doc></CONTAINS>
		<CONTAINED_BY><haxe_doc> The element we're testing against is a parent of this element </haxe_doc></CONTAINED_BY>
		<haxe_doc>
XmlNodePosition is used to describe the relationship between two nodes.  
It is used by XmlNode.compareDocumentPosition()

Please note haxedoc seems to have screwed up the order of the descriptions below.
</haxe_doc>
	</enum>
	<class path="haxe.io.Output" params="" file="/usr/share/haxe/haxe/io/Output.hx">
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<writeByte public="1" set="method" line="37"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="41"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="64"><f a=""><e path="Void"/></f></flush>
		<close public="1" set="method" line="67"><f a=""><e path="Void"/></f></close>
		<setEndian set="method" line="70"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<write public="1" set="method" line="77"><f a="s">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></write>
		<writeFullBytes public="1" set="method" line="88"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeFullBytes>
		<writeFloat public="1" set="method" line="96"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method" line="108"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeInt8 public="1" set="method" line="120"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeInt16 public="1" set="method" line="126"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeUInt16 public="1" set="method" line="131"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt24 public="1" set="method" line="142"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt24>
		<writeUInt24 public="1" set="method" line="147"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt24>
		<writeInt31 public="1" set="method" line="160"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt30 public="1" set="method" line="177"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt32 public="1" set="method" line="192"><f a="x">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<prepare public="1" set="method" line="212">
			<f a="nbytes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.
	</haxe_doc>
		</prepare>
		<writeInput public="1" set="method" line="215"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeInput>
		<writeString public="1" set="method" line="237"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<haxe_doc>
	An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.
</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/share/haxe/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="211" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="239" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="278" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" get="inline" set="null" line="51"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" set="method" line="65"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" set="method" line="93"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method" line="112"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" set="method" line="148"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" set="method" line="192"><f a=""><c path="String"/></f></toString>
		<getData public="1" get="inline" set="null" line="207"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="Date" params="" file="/usr/share/haxe/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new date object.
	</haxe_doc>
		</new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="IntIter" params="" file="/usr/share/haxe/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="php.Lib" params="" file="/usr/share/haxe/php/Lib.hx">
		<print public="1" set="method" line="7" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output.
	</haxe_doc>
		</print>
		<println public="1" set="method" line="14" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Print the specified value on the default output followed by a newline character.
	</haxe_doc>
		</println>
		<dump public="1" set="method" line="19" static="1"><f a="v">
	<d/>
	<e path="Void"/>
</f></dump>
		<serialize public="1" set="method" line="27" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize using native PHP serialization. This will return a Binary string that can be
		stored for long term usage.
	</haxe_doc>
		</serialize>
		<unserialize public="1" set="method" line="34" static="1">
			<f a="s">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a string using native PHP serialization. See [serialize].
	</haxe_doc>
		</unserialize>
		<extensionLoaded public="1" set="method" line="38" static="1"><f a="name">
	<c path="String"/>
	<unknown/>
</f></extensionLoaded>
		<isCli public="1" set="method" line="42" static="1"><f a=""><e path="Bool"/></f></isCli>
		<printFile public="1" set="method" line="46" static="1"><f a="file">
	<c path="String"/>
	<unknown/>
</f></printFile>
		<toPhpArray public="1" get="inline" set="null" line="50" static="1"><f a="a">
	<c path="Array"><d/></c>
	<c path="php.NativeArray"/>
</f></toPhpArray>
		<toHaxeArray public="1" get="inline" set="null" line="54" static="1"><f a="a">
	<c path="php.NativeArray"/>
	<c path="Array"><d/></c>
</f></toHaxeArray>
		<hashOfAssociativeArray public="1" params="T" set="method" line="58" static="1"><f a="arr">
	<c path="php.NativeArray"/>
	<c path="Hash"><c path="hashOfAssociativeArray.T"/></c>
</f></hashOfAssociativeArray>
		<associativeArrayOfHash public="1" set="method" line="64" static="1"><f a="hash">
	<c path="Hash"><d/></c>
	<c path="php.NativeArray"/>
</f></associativeArrayOfHash>
		<rethrow public="1" get="inline" set="null" line="71" static="1">
			<f a="e">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		For neko compatibility only.
	</haxe_doc>
		</rethrow>
		<appendType set="method" line="80" static="1"><f a="o:path:t">
	<d/>
	<c path="Array"><c path="String"/></c>
	<d/>
	<e path="Void"/>
</f></appendType>
		<getClasses public="1" set="method" line="91" static="1"><f a=""><a/></f></getClasses>
	</class>
	<class path="php.Web" params="" file="/usr/share/haxe/php/Web.hx">
		<getParams public="1" set="method" line="12" static="1">
			<f a=""><c path="Hash"><c path="String"/></c></f>
			<haxe_doc>
		Returns the GET and POST parameters.
	</haxe_doc>
		</getParams>
		<getParamValues public="1" set="method" line="40" static="1">
			<f a="param">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns an Array of Strings built using GET / POST values.
		If you have in your URL the parameters [a[]=foo;a[]=hello;a[5]=bar;a[3]=baz] then
		[php.Web.getParamValues("a")] will return [["foo","hello",null,"baz",null,"bar"]]
	</haxe_doc>
		</getParamValues>
		<getHostName public="1" get="inline" set="null" line="79" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the local server host name
	</haxe_doc>
		</getHostName>
		<getClientIP public="1" get="inline" set="null" line="86" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Surprisingly returns the client IP address.
	</haxe_doc>
		</getClientIP>
		<getURI public="1" set="method" line="93" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the original request URL (before any server internal redirections)
	</haxe_doc>
		</getURI>
		<redirect public="1" set="method" line="101" static="1">
			<f a="url">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Tell the client to redirect to the given url ("Location" header)
	</haxe_doc>
		</redirect>
		<setHeader public="1" get="inline" set="null" line="109" static="1">
			<f a="h:v">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an output header value. If some data have been printed, the headers have
		already been sent so this will raise an exception.
	</haxe_doc>
		</setHeader>
		<setReturnCode public="1" set="method" line="117" static="1">
			<f a="r">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the HTTP return code. Same remark as setHeader.
		See status code explanation here: http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
	</haxe_doc>
		</setReturnCode>
		<getClientHeader public="1" set="method" line="168" static="1">
			<f a="k">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Retrieve a client header value sent with the request.
	</haxe_doc>
		</getClientHeader>
		<_client_headers static="1"><c path="List"><a>
	<value><c path="String"/></value>
	<header><c path="String"/></header>
</a></c></_client_headers>
		<getClientHeaders public="1" set="method" line="183" static="1">
			<f a=""><c path="List"><a>
	<value><c path="String"/></value>
	<header><c path="String"/></header>
</a></c></f>
			<haxe_doc>
		Retrieve all the client headers.
	</haxe_doc>
		</getClientHeaders>
		<getParamsString public="1" get="inline" set="null" line="199" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns all the GET parameters String
	</haxe_doc>
		</getParamsString>
		<getPostData public="1" set="method" line="211" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns all the POST data. POST Data is always parsed as
		being application/x-www-form-urlencoded and is stored into
		the getParams hashtable. POST Data is maximimized to 256K
		unless the content type is multipart/form-data. In that
		case, you will have to use [getMultipart] or [parseMultipart]
		methods.
	</haxe_doc>
		</getPostData>
		<getCookies public="1" set="method" line="229" static="1">
			<f a=""><c path="Hash"><unknown/></c></f>
			<haxe_doc>
		Returns an hashtable of all Cookies sent by the client.
		Modifying the hashtable will not modify the cookie, use setCookie instead.
	</haxe_doc>
		</getCookies>
		<setCookie public="1" set="method" line="237" static="1">
			<f a="key:value:?expire:?domain:?path:?secure">
				<c path="String"/>
				<c path="String"/>
				<c path="Date"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a Cookie value in the HTTP headers. Same remark as setHeader.
	</haxe_doc>
		</setCookie>
		<addPair set="method" line="245" static="1"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></addPair>
		<getAuthorization public="1" set="method" line="253" static="1">
			<f a=""><a>
	<user><c path="String"/></user>
	<pass><c path="String"/></pass>
</a></f>
			<haxe_doc>
		Returns an object with the authorization sent by the client (Basic scheme only).
	</haxe_doc>
		</getAuthorization>
		<getCwd public="1" get="inline" set="null" line="262" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Get the current script directory in the local filesystem.
	</haxe_doc>
		</getCwd>
		<getMultipart public="1" set="method" line="270" static="1">
			<f a="maxSize">
				<c path="Int"/>
				<c path="Hash"><c path="String"/></c>
			</f>
			<haxe_doc>
		Get the multipart parameters as an hashtable. The data
		cannot exceed the maximum size specified.
	</haxe_doc>
		</getMultipart>
		<parseMultipart public="1" set="method" line="299" static="1">
			<f a="onPart:onData">
				<f a=":">
					<c path="String"/>
					<c path="String"/>
					<e path="Void"/>
				</f>
				<f a="::">
					<c path="String"/>
					<c path="Int"/>
					<c path="Int"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Parse the multipart data. Call [onPart] when a new part is found
		with the part name and the filename if present
		and [onData] when some part data is readed. You can this way
		directly save the data on hard drive in the case of a file upload.
	</haxe_doc>
		</parseMultipart>
		<flush public="1" get="inline" set="null" line="335" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Flush the data sent to the client. By default on Apache, outgoing data is buffered so
		this can be useful for displaying some long operation progress.
	</haxe_doc>
		</flush>
		<getMethod public="1" set="method" line="342" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Get the HTTP method used by the client.
	</haxe_doc>
		</getMethod>
		<isModNeko public="1" set="null" static="1"><e path="Bool"/></isModNeko>
		<haxe_doc>
	This class is used for accessing the local Web server and the current
	client request and informations.
</haxe_doc>
	</class>
	<enum path="php.io.FileHandle" params="" file="/usr/share/haxe/php/io/File.hx" module="php.io.File"/>
	<enum path="php.io.FileSeek" params="" file="/usr/share/haxe/php/io/File.hx" module="php.io.File">
		<SeekEnd/>
		<SeekCur/>
		<SeekBegin/>
	</enum>
	<class path="php.io.File" params="" file="/usr/share/haxe/php/io/File.hx">
		<getContent public="1" set="method" line="41" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<getBytes public="1" set="method" line="45" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<putContent public="1" set="method" line="49" static="1"><f a="path:content">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></putContent>
		<read public="1" set="method" line="53" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="php.io.FileInput"/>
</f></read>
		<write public="1" set="method" line="57" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="php.io.FileOutput"/>
</f></write>
		<append public="1" set="method" line="61" static="1"><f a="path:binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="php.io.FileOutput"/>
</f></append>
		<copy public="1" set="method" line="65" static="1"><f a="src:dst">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></copy>
		<stdin public="1" set="method" line="69" static="1"><f a=""><c path="php.io.FileInput"/></f></stdin>
		<stdout public="1" set="method" line="73" static="1"><f a=""><c path="php.io.FileOutput"/></f></stdout>
		<stderr public="1" set="method" line="77" static="1"><f a=""><c path="php.io.FileOutput"/></f></stderr>
		<getChar public="1" set="method" line="81" static="1"><f a="echo">
	<e path="Bool"/>
	<c path="Int"/>
</f></getChar>
		<haxe_doc>
	API for reading and writing to files.
</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/share/haxe/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<class path="Std" params="" file="/usr/share/haxe/Std.hx">
		<is public="1" set="method" line="34" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" set="method" line="54" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="74" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="90" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="131" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="153" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<enum path="Void" params="" file="/usr/share/haxe/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="/usr/share/haxe/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="/usr/share/haxe/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="/usr/share/haxe/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/share/haxe/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/share/haxe/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/share/haxe/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/share/haxe/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/share/haxe/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<class path="Lambda" params="" file="/usr/share/haxe/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>
		Creates an [Array] from an [Iterable]
	</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="48" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>
		Creates a [List] from an [Iterable]
	</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="62" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>
		Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.
	</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="75" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>
		Similar to [map], but also pass an index for each item iterated.
	</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="93" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.
	</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="112" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if at least one element of the iterable is found by using the specific function.
	</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if all elements of the iterable have the specified property defined by [f].
	</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="138" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Call the function 'f' on all elements of the [Iterable] 'it'.
	</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="149" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>
		Return the list of elements matching the function 'f'
	</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="163" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>
		Functional 'fold' using an [Iterable]
	</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="175" static="1">
			<f a="it">
				<t path="Iterable"><c path="count.A"/></t>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Count the number of elements in an [Iterable]
	</haxe_doc>
		</count>
		<empty public="1" set="method" line="188" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an iterable does not contain any element.
	</haxe_doc>
		</empty>
		<haxe_doc>
	The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.
</haxe_doc>
	</class>
	<class path="php.db.Object" params="" file="/usr/share/haxe/php/db/Object.hx">
		<__cache__><c path="php.db.Object"/></__cache__>
		<__noupdate__><e path="Bool"/></__noupdate__>
		<__manager__><a>
	<objectToString set="method"><f a="o">
	<c path="php.db.Object"/>
	<c path="String"/>
</f></objectToString>
	<doUpdate set="method"><f a="o">
	<c path="php.db.Object"/>
	<e path="Void"/>
</f></doUpdate>
	<doSync set="method"><f a="o">
	<c path="php.db.Object"/>
	<e path="Void"/>
</f></doSync>
	<doInsert set="method"><f a="o">
	<c path="php.db.Object"/>
	<e path="Void"/>
</f></doInsert>
	<doDelete set="method"><f a="o">
	<c path="php.db.Object"/>
	<e path="Void"/>
</f></doDelete>
</a></__manager__>
		<__init_object set="method" line="59"><f a=""><e path="Void"/></f></__init_object>
		<insert public="1" set="method" line="71"><f a=""><e path="Void"/></f></insert>
		<update public="1" set="method" line="75"><f a=""><e path="Void"/></f></update>
		<sync public="1" set="method" line="80"><f a=""><e path="Void"/></f></sync>
		<delete public="1" set="method" line="84"><f a=""><e path="Void"/></f></delete>
		<toString public="1" set="method" line="88"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="55"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	SPOD Object : the persistent object base type. See the tutorial on haXe
	website to learn how to use SPOD.
</haxe_doc>
	</class>
	<class path="php.PhpDate__" params="" file="/usr/share/haxe/php/PhpDate__.hx">
		<__name__ line="29" static="1"><c path="Array"><c path="String"/></c></__name__>
		<now public="1" set="method" line="77" static="1"><f a=""><c path="php.PhpDate__"/></f></now>
		<fromPhpTime public="1" set="method" line="81" static="1"><f a="t">
	<c path="Float"/>
	<c path="php.PhpDate__"/>
</f></fromPhpTime>
		<fromTime public="1" set="method" line="87" static="1"><f a="t">
	<c path="Float"/>
	<c path="php.PhpDate__"/>
</f></fromTime>
		<fromString public="1" set="method" line="93" static="1"><f a="s">
	<c path="String"/>
	<c path="php.PhpDate__"/>
</f></fromString>
		<__t><c path="Float"/></__t>
		<getTime public="1" set="method" line="36"><f a=""><c path="Float"/></f></getTime>
		<getPhpTime public="1" set="method" line="40"><f a=""><c path="Float"/></f></getPhpTime>
		<getFullYear public="1" set="method" line="44"><f a=""><c path="Int"/></f></getFullYear>
		<getMonth public="1" set="method" line="48"><f a=""><c path="Int"/></f></getMonth>
		<getDate public="1" set="method" line="53"><f a=""><c path="Int"/></f></getDate>
		<getHours public="1" set="method" line="57"><f a=""><c path="Int"/></f></getHours>
		<getMinutes public="1" set="method" line="61"><f a=""><c path="Int"/></f></getMinutes>
		<getSeconds public="1" set="method" line="65"><f a=""><c path="Int"/></f></getSeconds>
		<getDay public="1" set="method" line="69"><f a=""><c path="Int"/></f></getDay>
		<toString public="1" set="method" line="73"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="32"><f a="year:month:day:hour:min:sec">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="php.io.FileOutput" params="" file="/usr/share/haxe/php/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<__f><e path="php.io.FileHandle"/></__f>
		<writeByte public="1" set="method" line="38" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="44" override="1"><f a="b:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<flush public="1" set="method" line="52" override="1"><f a=""><e path="Void"/></f></flush>
		<close public="1" set="method" line="57" override="1"><f a=""><e path="Void"/></f></close>
		<seek public="1" set="method" line="62"><f a="p:pos">
	<c path="Int"/>
	<e path="php.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<tell public="1" set="method" line="73"><f a=""><c path="Int"/></f></tell>
		<eof public="1" set="method" line="79"><f a=""><e path="Bool"/></f></eof>
		<new public="1" set="method" line="34"><f a="f">
	<e path="php.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Use [php.io.File.write] to create a [FileOutput]
</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="/usr/share/haxe/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
		<haxe_doc>
	The diffent possible runtime types of a value.
	See [Type] for the haXe Reflection API.
</haxe_doc>
	</enum>
	<class path="Type" params="" file="/usr/share/haxe/Type.hx">
		<getClass public="1" params="T" set="method" line="26" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="89" static="1">
			<f a="o">
				<d/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="129" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="152" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="177" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="194" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="256" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="313" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="365" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="421" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="442" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor index and parameters.
	</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="467" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="516" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="559" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="580" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="703" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="775" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="790" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="810" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="basehx.DbControl" params="" file="src/basehx/DbControl.hx">
		<cnx public="1" line="5" static="1"><c path="php.db.Connection"/></cnx>
		<connect public="1" set="method" line="7" static="1"><f a=""><e path="Void"/></f></connect>
		<close public="1" set="method" line="37" static="1"><f a=""><e path="Void"/></f></close>
	</class>
	<class path="haxe.io.Eof" params="" file="/usr/share/haxe/haxe/io/Eof.hx">
		<toString set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	This exception is raised when reading while data is no longer available in the [Input].
</haxe_doc>
	</class>
	<class path="php.NativeString" params="" file="/usr/share/haxe/php/NativeString.hx" extern="1"/>
	<class path="php.PhpMath__" params="" file="/usr/share/haxe/php/PhpMath__.hx">
		<PI public="1" static="1"><unknown/></PI>
		<NaN public="1" static="1"><unknown/></NaN>
		<POSITIVE_INFINITY public="1" static="1"><c path="Int"/></POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" static="1"><c path="Int"/></NEGATIVE_INFINITY>
		<abs public="1" set="method" line="34" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></abs>
		<min public="1" set="method" line="35" static="1"><f a="a:b">
	<unknown/>
	<unknown/>
	<unknown/>
</f></min>
		<max public="1" set="method" line="36" static="1"><f a="a:b">
	<unknown/>
	<unknown/>
	<unknown/>
</f></max>
		<sin public="1" set="method" line="37" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></sin>
		<cos public="1" set="method" line="38" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></cos>
		<atan2 public="1" set="method" line="39" static="1"><f a="y:x">
	<unknown/>
	<unknown/>
	<unknown/>
</f></atan2>
		<tan public="1" set="method" line="40" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></tan>
		<exp public="1" set="method" line="41" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></exp>
		<log public="1" set="method" line="42" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></log>
		<sqrt public="1" set="method" line="43" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></sqrt>
		<round public="1" set="method" line="44" static="1"><f a="v">
	<c path="Float"/>
	<unknown/>
</f></round>
		<floor public="1" set="method" line="45" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></floor>
		<ceil public="1" set="method" line="46" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></ceil>
		<atan public="1" set="method" line="47" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></atan>
		<asin public="1" set="method" line="48" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></asin>
		<acos public="1" set="method" line="49" static="1"><f a="v">
	<unknown/>
	<unknown/>
</f></acos>
		<pow public="1" set="method" line="50" static="1"><f a="b:e">
	<unknown/>
	<unknown/>
	<unknown/>
</f></pow>
		<random public="1" set="method" line="51" static="1"><f a=""><unknown/></f></random>
		<isNaN public="1" set="method" line="52" static="1"><f a="f">
	<unknown/>
	<unknown/>
</f></isNaN>
		<isFinite public="1" set="method" line="53" static="1"><f a="f">
	<unknown/>
	<unknown/>
</f></isFinite>
	</class>
	<class path="php.io.FileInput" params="" file="/usr/share/haxe/php/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<__f><e path="php.io.FileHandle"/></__f>
		<readByte public="1" set="method" line="39" override="1"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="46" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" set="method" line="55" override="1"><f a=""><e path="Void"/></f></close>
		<seek public="1" set="method" line="60"><f a="p:pos">
	<c path="Int"/>
	<e path="php.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<tell public="1" set="method" line="71"><f a=""><c path="Int"/></f></tell>
		<new public="1" set="method" line="35"><f a="f">
	<e path="php.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	Use [php.io.File.read] to create a [FileInput]
</haxe_doc>
	</class>
	<class path="php.db.Manager" params="T" file="/usr/share/haxe/php/db/Manager.hx">
		<cnx public="1" set="setConnection" static="1"><c path="php.db.Connection"/></cnx>
		<object_cache line="38" static="1"><c path="Hash"><c path="php.db.Object"/></c></object_cache>
		<cache_field line="39" static="1"><c path="String"/></cache_field>
		<FOR_UPDATE line="40" static="1"><c path="String"/></FOR_UPDATE>
		<managers public="1" line="42" static="1"><c path="Hash"><c path="php.db.Manager"><d/></c></c></managers>
		<setConnection set="dynamic" line="44" static="1"><f a="c">
	<c path="php.db.Connection"/>
	<c path="php.db.Connection"/>
</f></setConnection>
		<initialize public="1" set="method" line="440" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	* Left for compability with neko SPOD
	</haxe_doc>
		</initialize>
		<cleanup public="1" set="method" line="444" static="1"><f a=""><e path="Void"/></f></cleanup>
		<table_name><c path="String"/></table_name>
		<table_fields><c path="List"><c path="String"/></c></table_fields>
		<table_keys><c path="Array"><c path="String"/></c></table_keys>
		<cls><d/></cls>
		<get public="1" set="method" line="116"><f a="id:?lock">
	<c path="Int"/>
	<e path="Bool"/>
	<c path="php.db.Manager.T"/>
</f></get>
		<getWithKeys public="1" set="method" line="138"><f a="keys:?lock">
	<a/>
	<e path="Bool"/>
	<c path="php.db.Manager.T"/>
</f></getWithKeys>
		<delete public="1" set="method" line="154"><f a="x">
	<a/>
	<e path="Void"/>
</f></delete>
		<search public="1" set="method" line="163"><f a="x:?lock">
	<a/>
	<e path="Bool"/>
	<c path="List"><c path="php.db.Manager.T"/></c>
</f></search>
		<addCondition set="method" line="176"><f a="s:x">
	<c path="StringBuf"/>
	<a/>
	<e path="Void"/>
</f></addCondition>
		<all public="1" set="method" line="197"><f a="?lock">
	<e path="Bool"/>
	<c path="List"><c path="php.db.Manager.T"/></c>
</f></all>
		<count public="1" set="method" line="203"><f a="?x">
	<a/>
	<c path="Int"/>
</f></count>
		<quote public="1" set="method" line="212"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></quote>
		<result public="1" set="method" line="216"><f a="sql">
	<c path="String"/>
	<d/>
</f></result>
		<results public="1" params="T" set="method" line="220"><f a="sql">
	<c path="String"/>
	<c path="List"><c path="results.T"/></c>
</f></results>
		<doInsert set="method" line="226"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></doInsert>
		<doUpdate set="method" line="259"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></doUpdate>
		<doDelete set="method" line="288"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></doDelete>
		<doSync set="method" line="298"><f a="i">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></doSync>
		<objectToString set="method" line="312"><f a="it">
	<c path="php.db.Manager.T"/>
	<c path="String"/>
</f></objectToString>
		<cacheObject set="method" line="337"><f a="x:lock">
	<c path="php.db.Manager.T"/>
	<e path="Bool"/>
	<c path="php.db.Manager.T"/>
</f></cacheObject>
		<make set="method" line="350"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></make>
		<unmake set="method" line="353"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></unmake>
		<quoteField set="method" line="356"><f a="f">
	<c path="String"/>
	<c path="String"/>
</f></quoteField>
		<addKeys set="method" line="363"><f a="s:x">
	<c path="StringBuf"/>
	<a/>
	<e path="Void"/>
</f></addKeys>
		<execute set="method" line="379"><f a="sql">
	<c path="String"/>
	<c path="php.db.ResultSet"/>
</f></execute>
		<select set="method" line="383"><f a="cond">
	<c path="String"/>
	<c path="String"/>
</f></select>
		<selectReadOnly set="method" line="393"><f a="cond">
	<c path="String"/>
	<c path="String"/>
</f></selectReadOnly>
		<object public="1" set="method" line="402"><f a="sql:lock">
	<c path="String"/>
	<e path="Bool"/>
	<c path="php.db.Manager.T"/>
</f></object>
		<objects public="1" set="method" line="414"><f a="sql:lock">
	<c path="String"/>
	<e path="Bool"/>
	<c path="List"><c path="php.db.Manager.T"/></c>
</f></objects>
		<dbClass public="1" set="method" line="431"><f a=""><c path="Class"><d/></c></f></dbClass>
		<initRelation set="method" line="448"><f a="o:r">
	<d/>
	<a>
		<prop><c path="String"/></prop>
		<manager><c path="php.db.Manager"><c path="php.db.Object"/></c></manager>
		<lock><e path="Bool"/></lock>
		<key><c path="String"/></key>
	</a>
	<e path="Void"/>
</f></initRelation>
		<makeCacheKey set="method" line="467"><f a="x">
	<c path="php.db.Manager.T"/>
	<c path="String"/>
</f></makeCacheKey>
		<addToCache set="method" line="486"><f a="x">
	<c path="php.db.Manager.T"/>
	<e path="Void"/>
</f></addToCache>
		<getFromCache set="method" line="490"><f a="x:lock">
	<c path="php.db.Manager.T"/>
	<e path="Bool"/>
	<c path="php.db.Manager.T"/>
</f></getFromCache>
		<new public="1" set="method" line="57"><f a="classval">
	<c path="Class"><c path="php.db.Object"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>
	SPOD Manager : the persistent object database manager. See the tutorial on
	haXe website to learn how to use SPOD.
</haxe_doc>
	</class>
	<class path="Class" params="T" file="/usr/share/haxe/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="String" params="" file="/usr/share/haxe/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<cca set="method"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></cca>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="Array" params="T" file="/usr/share/haxe/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="controllers.UsersController" params="" file="src/controllers/UsersController.hx">
		<extends path="basehx.BaseController"/>
		<aliases public="1" line="5" static="1"><c path="Array"><c path="String"/></c></aliases>
		<getDefaultAction public="1" set="method" line="7" override="1"><f a=""><f a=""><e path="Void"/></f></f></getDefaultAction>
		<list set="method" line="12"><f a=""><e path="Void"/></f></list>
		<new public="1" set="method" line="3"><f a="args">
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/share/haxe/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="php.Exception" params="" file="/usr/share/haxe/php/Exception.hx" extern="1">
		<message><c path="String"/></message>
		<code><c path="Int"/></code>
		<file><c path="String"/></file>
		<line><c path="Int"/></line>
		<getMessage public="1" set="method"><f a=""><c path="String"/></f></getMessage>
		<getCode public="1" set="method"><f a=""><c path="Int"/></f></getCode>
		<getFile public="1" set="method"><f a=""><c path="String"/></f></getFile>
		<getLine public="1" set="method"><f a=""><c path="Int"/></f></getLine>
		<getTrace public="1" set="method"><f a=""><c path="Array"><c path="String"/></c></f></getTrace>
		<getTraceAsString public="1" set="method"><f a=""><c path="String"/></f></getTraceAsString>
		<__toString public="1" set="method"><f a=""><c path="String"/></f></__toString>
		<new public="1" set="method"><f a="?message:?code">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/share/haxe/haxe/io/BytesData.hx"><c path="php.NativeString"/></typedef>
	<class path="@Main" params="" file=""><init line="1" static="1"><e path="Void"/></init></class>
</haxe>